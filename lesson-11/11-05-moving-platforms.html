<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 11 · Step 5 — Moving Platforms (Ride + Carry)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#131722}
  #app{width:100%;height:100%}
  .hud{position:fixed;top:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.55);color:#fff;font:13px/1.35 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.45);color:#fff;font:12px/1.35 monospace}
  #dz{position:fixed;left:0;top:0;pointer-events:none;border:2px solid rgba(255,255,255,.85)}
</style>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="hud" class="hud">
  L11 · Step 5 — grounded=false · vy=0.00 · carry=0.00,0.00 · slope=— · coyote=0.00 · buffer=0.00 · drop=0.00 · clamp=on
</div>
<div id="dz"></div>
<div class="help">
  Move: <b>A/D</b> · Jump: <b>Space/W/↑</b> · <b>Down+Jump</b> drops through <u>one-way</u> only · Rays: <b>G</b> · Sweep: <b>C</b> · Wireframe: <b>H</b> · Reset: <b>R</b><br/>
  Parallax: <b>1/2/3/4</b> · <b>M</b> clamp on/off · Bounds: <b>B</b> · Ortho/Persp: <b>P</b> · PPU: <b>K</b>/<b>L</b>
</div>

<script type="module">
const THREE = await import('three');

const app  = document.getElementById('app');
const hud  = document.getElementById('hud');
const dzEl = document.getElementById('dz');

// ---------------- Renderer ----------------
const renderer = new THREE.WebGLRenderer({ antialias:true });
app.appendChild(renderer.domElement);
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x131722);
if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

// ---------------- Scene & Layers ----------------
const scene = new THREE.Scene();
const bg  = new THREE.Group();  bg.userData.parallax  = 0.25;
const mid = new THREE.Group();  mid.userData.parallax = 1.00;
const fg  = new THREE.Group();  fg.userData.parallax  = 1.50;
bg.position.z=-10; mid.position.z=0; fg.position.z=10;
scene.add(bg, mid, fg);

// Sky gradient
const skyMat = new THREE.ShaderMaterial({
  uniforms:{ top:{value:new THREE.Color(0x334a7a)}, bottom:{value:new THREE.Color(0x1a2336)} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`uniform vec3 top; uniform vec3 bottom; varying vec2 vUv;
    void main(){ vec3 c = mix(bottom, top, clamp(vUv.y,0.0,1.0)); gl_FragColor=vec4(c,1.0); }`
});
skyMat.depthWrite=false; skyMat.depthTest=false;
const sky = new THREE.Mesh(new THREE.PlaneGeometry(1,1), skyMat);
sky.renderOrder = -100; bg.add(sky);

// ---------------- Level geometry ----------------
const LEVEL_Z = -0.05;
const THICK   = 0.30;
const groundMat = new THREE.MeshStandardMaterial({ color:0x2e3758, roughness:0.9 });
const rampMat   = new THREE.MeshStandardMaterial({ color:0x3a5b8f, roughness:0.85 });
const oneWayMat = new THREE.MeshStandardMaterial({ color:0x7d5cff, roughness:0.6, emissive:0x171133, emissiveIntensity:0.25 });
// === NEW: material for movers
const moverMat  = new THREE.MeshStandardMaterial({ color:0xffa200, roughness:0.55, metalness:0.0, emissive:0x331a00, emissiveIntensity:0.25 });

let groundWireframe=false;
function setWireframe(on){ groundMat.wireframe=on; rampMat.wireframe=on; oneWayMat.wireframe=on; moverMat.wireframe=on; }

const level = new THREE.Group(); level.position.z = LEVEL_Z; mid.add(level);

function flat(w, y=-1, x=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,0.5,THICK), groundMat);
  m.position.set(x,y-0.25,0); m.receiveShadow=true; return m;
}
function ramp(w, h, x=0, y=-1, up=true){
  const s = new THREE.Shape();
  if (up){ s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(w/2,h); }
  else   { s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(-w/2,h); }
  s.closePath();
  const geo = new THREE.ExtrudeGeometry(s, { depth: THICK, bevelEnabled:false });
  geo.translate(0,0,-THICK/2);
  const m = new THREE.Mesh(geo, rampMat);
  m.position.set(x,y,0); m.receiveShadow=true; return m;
}
function oneWay(w=4, x=0, y=1.2){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.18, THICK*0.7), oneWayMat);
  m.position.set(x, y, 0);
  m.userData.oneWay = true;
  return m;
}

// === NEW: moving platform factory (ping-pong between from→to)
function movingPlatform({from=[0,0], to=[4,0], w=3, h=0.35, speed=2.0}){
  const geo = new THREE.BoxGeometry(w, h, THICK);
  const m = new THREE.Mesh(geo, moverMat);
  // 'from'/'to' are the TOP surface coordinates; we store h to maintain top alignment
  m.userData.mover = {
    from: new THREE.Vector2(from[0], from[1]),
    to:   new THREE.Vector2(to[0],   to[1]),
    u: 0, dir: 1, speed, len: new THREE.Vector2(to[0]-from[0], to[1]-from[1]).length(),
    h, last: new THREE.Vector2(), delta: new THREE.Vector2()
  };
  // place at 'from' (center y = topY - h/2)
  m.position.set(from[0], from[1]-h*0.5, 0);
  m.userData.mover.last.set(m.position.x, m.position.y);
  level.add(m);
  return m;
}

// Course
level.add(flat(12,-1, -12));
level.add(ramp(8,3, -1,-1, true));
level.add(flat(10, 0.5, 8));
level.add(ramp(6,-2, 14,0.5, false));
level.add(flat(12,-1, 23));
level.add(oneWay(4, 5.5, 1.1));
level.add(oneWay(5, 18.0, 2.3));

// === NEW: add movers (one horizontal bridge, one vertical elevator)
const movers = [];
movers.push(movingPlatform({ from:[-4, 1.4], to:[ 2, 1.4], w:3.5, h:0.35, speed:2.0 })); // horizontal ping-pong
movers.push(movingPlatform({ from:[16, 0.8], to:[16, 3.2], w:3.5, h:0.35, speed:1.6 })); // vertical ping-pong

// ---------------- Lights ----------------
scene.add(new THREE.HemisphereLight(0x9fb8ff, 0x1b2030, 0.65));
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const dir = new THREE.DirectionalLight(0xffffff,1.25); dir.position.set(6,10,6); scene.add(dir);

// ---------------- Camera rig (ortho + clamp) ----------------
let PIXELS_PER_UNIT=64; const MIN_PPU=16, MAX_PPU=256;
const aspect = ()=> window.innerWidth / window.innerHeight;

const ortho = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
ortho.position.set(0,0,10); ortho.lookAt(0,0,0);

const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
let perspDist=10; persp.position.set(0,0,perspDist); persp.lookAt(0,0,0);

let usingOrtho=true; let camera=ortho;
let camX=0, camY=0, camVX=0, camVY=0;

const WORLD = { minX:-14, maxX:26, minY:-4, maxY:8 };
let clampEnabled = true;

function visibleUnitsOrtho(){ const halfH=(window.innerHeight/PIXELS_PER_UNIT)*0.5; return [halfH*aspect(), halfH]; }
function visibleUnitsPersp(){ const halfH=Math.tan((Math.PI/180)*(persp.fov*0.5))*perspDist; return [halfH*aspect(), halfH]; }
function visibleUnits(){ return usingOrtho?visibleUnitsOrtho():visibleUnitsPersp(); }
function sizeSky(){ const [halfW,halfH]=visibleUnits(); sky.scale.set(halfW*4,halfH*2,1); }

function updateOrtho(){
  const [halfW,halfH]=visibleUnitsOrtho();
  ortho.left=-halfW+camX; ortho.right=halfW+camX; ortho.top=halfH+camY; ortho.bottom=-halfH+camY;
  ortho.updateProjectionMatrix();
  ortho.position.set(camX,camY,10); ortho.lookAt(camX,camY,0);
  sizeSky();
}
function updatePersp(){
  persp.aspect=aspect(); persp.updateProjectionMatrix();
  persp.position.set(camX,camY,perspDist); persp.lookAt(camX,camY,0);
  sizeSky();
}
function clampToWorld(cx, cy){
  const [halfW, halfH] = visibleUnits();
  const minX = WORLD.minX + halfW, maxX = WORLD.maxX - halfW;
  const minY = WORLD.minY + halfH, maxY = WORLD.maxY - halfH;
  const worldW=WORLD.maxX-WORLD.minX, worldH=WORLD.maxY-WORLD.minY;
  const viewW=halfW*2, viewH=halfH*2;
  return [
    (viewW>=worldW)?(WORLD.minX+WORLD.maxX)/2:THREE.MathUtils.clamp(cx,minX,maxX),
    (viewH>=worldH)?(WORLD.minY+WORLD.maxY)/2:THREE.MathUtils.clamp(cy,minY,maxY)
  ];
}

let DZ_W=0.40, DZ_H=0.30; const EPS = 1e-3;
function dzBounds(moveX=0, moveY=0){
  const [halfW, halfH] = visibleUnits();
  const viewL = camX - halfW, viewR = camX + halfW;
  const viewB = camY - halfH, viewT = camY + halfH;
  if(!clampEnabled){
    const dzHalfW = halfW * DZ_W, dzHalfH = halfH * DZ_H;
    return { left:camX-dzHalfW, right:camX+dzHalfW, bottom:camY-dzHalfH, top:camY+dzHalfH, halfW, halfH, viewL, viewB };
  }
  const atL = Math.abs(camX - (WORLD.minX + halfW)) <= EPS;
  const atR = Math.abs(camX - (WORLD.maxX - halfW)) <= EPS;
  const atB = Math.abs(camY - (WORLD.minY + halfH)) <= EPS;
  const atT = Math.abs(camY - (WORLD.maxY - halfH)) <= EPS;
  const dzHalfW = halfW * DZ_W, dzHalfH = halfH * DZ_H;
  let left = camX - dzHalfW, right = camX + dzHalfW, bottom = camY - dzHalfH, top = camY + dzHalfH;
  if (atL && moveX < -0.001) { left  = viewL; right = Math.min(viewL + 2*dzHalfW, viewR); }
  if (atR && moveX >  0.001) { right = viewR; left  = Math.max(viewR - 2*dzHalfW, viewL); }
  if (atB && moveY < -0.001) { bottom= viewB; top   = Math.min(viewB + 2*dzHalfH, viewT); }
  if (atT && moveY >  0.001) { top   = viewT; bottom= Math.max(viewT - 2*dzHalfH, viewB); }
  return { left, right, bottom, top, halfW, halfH, viewL, viewB };
}
function updateDZHud(dz){
  const pxW = ((dz.right  - dz.left)   / (2*dz.halfW)) * innerWidth;
  const pxH = ((dz.top    - dz.bottom) / (2*dz.halfH)) * innerHeight;
  const pxX = ((dz.left   - dz.viewL)  / (2*dz.halfW)) * innerWidth;
  const pxY = ((dz.bottom - dz.viewB)  / (2*dz.halfH)) * innerHeight;
  dzEl.style.width  = Math.round(pxW) + 'px';
  dzEl.style.height = Math.round(pxH) + 'px';
  dzEl.style.left   = Math.round(pxX) + 'px';
  dzEl.style.top    = Math.round(pxY) + 'px';
}

// Direction-aware camera follow
function followCamera(dt){
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;
  const dz = dzBounds(moveX, moveY);
  let shiftX = 0, shiftY = 0;
  if (player.position.x < dz.left)   shiftX = player.position.x - dz.left;
  if (player.position.x > dz.right)  shiftX = player.position.x - dz.right;
  if (player.position.y < dz.bottom) shiftY = player.position.y - dz.bottom;
  if (player.position.y > dz.top)    shiftY = player.position.y - dz.top;
  let targetX = camX + shiftX, targetY = camY + shiftY;
  if (clampEnabled) [targetX, targetY] = clampToWorld(targetX, targetY);
  const ax = STIFF * (targetX - camX) - DAMP * camVX;
  const ay = STIFF * (targetY - camY) - DAMP * camVY;
  camVX += ax * dt;  camVY += ay * dt;
  camX  += camVX * dt; camY  += camVY * dt;
}

function applyParallax(){
  const set=(g,f)=>{ g.position.x = camX*(1-f); g.position.y = camY*(1-f); };
  set(bg, bg.userData.parallax); set(mid, mid.userData.parallax); set(fg, fg.userData.parallax);
}
function updateRig(){
  if(usingOrtho){ camera=ortho; updateOrtho(); } else { camera=persp; updatePersp(); }
  applyParallax();
}

// ---------------- Player controller (with one-way) ----------------
const PLAYER_HEIGHT=1.1, PLAYER_HALF=PLAYER_HEIGHT*0.5, PLAYER_WIDTH=0.8;
const MOVE_SPEED=6.0, AIR_SPEED=5.0;
const GRAVITY=-18.0;
const JUMP_SPEED=8.5;
const JUMP_CUT_MULT=2.4;
const SNAP_DIST=0.35, MAX_SLOPE_DEG=38;
const COYOTE_TIME=0.12, JUMP_BUFFER=0.12;
const SNAP_LOCK_AFTER_JUMP=0.06;
const SKIN=0.02, RADIUS=PLAYER_WIDTH*0.5;

// Drop-through gating (from your working patch)
const DOWN_BUFFER = 0.20, DROP_ARM_TIME = 0.25;
let downBuffer = 0, dropArmed = 0;
const DROP_TIME=0.25, DROP_LOCK=0.08;
let dropIgnoreObj=null, dropTimer=0;

const player = new THREE.Mesh(
  new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, 0.8),
  new THREE.MeshStandardMaterial({ color:0x88ff88, emissive:0x224422, emissiveIntensity:0.12 })
);
player.position.set(-12,-0.2,+0.05);
mid.add(player);

let lastPlayerX = player.position.x, lastPlayerY = player.position.y;

const raycaster = new THREE.Raycaster();
const UP = new THREE.Vector3(0,1,0);
let grounded=false, slopeDeg=0, groundNormal=new THREE.Vector3(0,1,0), lastGround=null;
let vx=0, vy=0, coyoteTimer=0, jumpBufferTimer=0, snapLock=0;
let jumpHeld=false, downHeld=false;

// === IMPORTANT: build colliders AFTER adding movers so they’re included
const colliders=[]; level.traverse(o=>{ if(o.isMesh) colliders.push(o); });

// Debug viz
const rayViz = new THREE.Group(); mid.add(rayViz);
const rayDown = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,-1,0)]), new THREE.LineBasicMaterial({ color:0x66ccff }));
const rayNormal = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,1,0)]), new THREE.LineBasicMaterial({ color:0xffaa00 }));
const sweepViz = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(1,0,0)]), new THREE.LineBasicMaterial({ color:0xff66ff }));
rayViz.add(rayDown, rayNormal, sweepViz);
let showRay=true, showSweep=false;

// Input
const input = { left:false, right:false };
addEventListener('keydown', e=>{
  const k=e.key.toLowerCase();
  if(k==='a'||k==='arrowleft')  input.left=true;
  if(k==='d'||k==='arrowright') input.right=true;
  if(k==='s'||k==='arrowdown'){ downHeld=true; downBuffer=DOWN_BUFFER; }
  if(k==='w'||k==='arrowup'||k===' '){
    const downNow = (downHeld || downBuffer > 0);
    if (downNow && grounded && lastGround && lastGround.userData.oneWay){
      requestDropThrough();
      jumpBufferTimer = 0; dropArmed = 0; return;
    }
    jumpHeld=true; jumpBufferTimer=JUMP_BUFFER;
    if (downNow) dropArmed = DROP_ARM_TIME;
  }
  if(k==='g'){ showRay=!showRay; rayDown.visible=rayNormal.visible=showRay; }
  if(k==='c'){ showSweep=!showSweep; sweepViz.visible=showSweep; }
  if(k==='h'){ groundWireframe=!groundWireframe; setWireframe(groundWireframe); }
  if(k==='r'){ player.position.set(-12,-0.2,+0.05); vx=vy=0; coyoteTimer=jumpBufferTimer=snapLock=dropTimer=0; lastGround=null; }
  if(k==='p'){ usingOrtho=!usingOrtho; updateRig(); }
  if(k==='m'){ clampEnabled=!clampEnabled; }
  if(k==='1'){ bg.userData.parallax=0.40; mid.userData.parallax=1.00; fg.userData.parallax=1.20; }
  if(k==='2'){ bg.userData.parallax=0.25; mid.userData.parallax=1.00; fg.userData.parallax=1.50; }
  if(k==='3'){ bg.userData.parallax=0.10; mid.userData.parallax=1.00; fg.userData.parallax=1.60; }
  if(k==='4'){ bg.userData.parallax=0.05; mid.userData.parallax=1.00; fg.userData.parallax=1.80; }
  if(k==='k') setPPU(PIXELS_PER_UNIT-4);
  if(k==='l') setPPU(PIXELS_PER_UNIT+4);
  if(k==='b'){ bounds.visible=!bounds.visible; }
});
addEventListener('keyup', e=>{
  const k=e.key.toLowerCase();
  if(k==='a'||k==='arrowleft')  input.left=false;
  if(k==='d'||k==='arrowright') input.right=false;
  if(k==='s'||k==='arrowdown')  downHeld=false;
  if(k==='w'||k==='arrowup'||k===' ') { jumpHeld=false; }
});
function setPPU(ppu){ PIXELS_PER_UNIT=THREE.MathUtils.clamp(ppu,MIN_PPU,MAX_PPU); }

// World bounds overlay
const bounds = new THREE.LineSegments((()=>{
  const g=new THREE.BufferGeometry();
  const p=new Float32Array([
    WORLD.minX,WORLD.minY,0, WORLD.maxX,WORLD.minY,0,
    WORLD.maxX,WORLD.minY,0, WORLD.maxX,WORLD.maxY,0,
    WORLD.maxX,WORLD.maxY,0, WORLD.minX,WORLD.maxY,0,
    WORLD.minX,WORLD.maxY,0, WORLD.minX,WORLD.minY,0
  ]);
  g.setAttribute('position', new THREE.BufferAttribute(p,3));
  return g;
})(), new THREE.LineBasicMaterial({ color:0x00ff99 }));
bounds.position.z = 0.01; bounds.visible=false; mid.add(bounds);

// -------- Ground snap (with one-way rules) --------
const normalMat = new THREE.Matrix3();
function snapToGround(prevFeetY){
  if(snapLock>0) { grounded=false; return; }
  grounded=false; slopeDeg=0;

  const origin = new THREE.Vector3(player.position.x, player.position.y - PLAYER_HALF + 0.05, player.position.z);
  const dir = new THREE.Vector3(0,-1,0);
  raycaster.set(origin, dir); raycaster.far = SNAP_DIST + 0.2;

  const hits = raycaster.intersectObjects(colliders, false);
  if(!hits.length){
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
    return;
  }

  for(const h of hits){
    if(!h.face) continue;
    const isOneWay = !!h.object.userData.oneWay;

    normalMat.getNormalMatrix(h.object.matrixWorld);
    const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();
    if(n.y <= 0.45) continue;

    const topY = h.point.y;
    const dy = origin.y - h.point.y;

    if(isOneWay){
      if(vy > 0) continue;                    // rising: pass-through
      if(prevFeetY < topY - 0.01) continue;   // from below: pass-through
      if(dropTimer > 0 && dropIgnoreObj === h.object) continue; // active drop
    }

    const angle = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(n.dot(UP),-1,1)));
    if(dy >= -0.02 && dy <= SNAP_DIST && angle <= MAX_SLOPE_DEG){
      player.position.y = topY + PLAYER_HALF;
      vy = 0; grounded=true; groundNormal.copy(n); lastGround=h.object;

      rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
      rayNormal.geometry.setFromPoints([h.point, h.point.clone().addScaledVector(n, 1.0)]);
      break;
    }
  }
}

// -------- Sweep collision (walls/ceilings only; ignore ground & one-way) --------
function sweepCollide(prevX, prevY, stepX, stepY){
  const dist = Math.hypot(stepX, stepY);
  if(dist <= 1e-6) return { dx:0, dy:0, hit:false };

  const dir = new THREE.Vector3(stepX/dist, stepY/dist, 0);
  const yFeet = prevY - PLAYER_HALF + 0.05;
  const yMid  = prevY;
  const yHead = prevY + PLAYER_HALF - 0.05;
  const origins = [
    new THREE.Vector3(prevX, yFeet, player.position.z),
    new THREE.Vector3(prevX, yMid,  player.position.z),
    new THREE.Vector3(prevX, yHead, player.position.z),
  ];

  const far = dist + RADIUS + SKIN; raycaster.far = far;
  let minHit = Infinity, best=null;

  for(const o of origins){
    raycaster.set(o, dir);
    const hits = raycaster.intersectObjects(colliders, false);
    if(!hits.length) continue;

    for(const h of hits){
      if(!h.face) continue;
      if(h.object.userData.oneWay) continue; // skip one-way in sweep

      normalMat.getNormalMatrix(h.object.matrixWorld);
      const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();

      if(stepY < 0 && n.y > 0.45) continue; // ignore ground while falling; snap handles it
      if(n.dot(dir) < -0.2 && h.distance < minHit){
        minHit = h.distance; best = { normal:n, point:h.point.clone() };
      }
      break; // nearest-first
    }
  }

  if(!best){
    if(showSweep){
      const a = new THREE.Vector3(prevX, prevY, player.position.z);
      sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, dist)]);
    }
    return { dx:stepX, dy:stepY, hit:false };
  }

  const allowed = Math.max(0, minHit - (RADIUS + SKIN));
  const dx = dir.x * allowed, dy = dir.y * allowed;
  if(stepY > 0 && best.normal.y < -0.3) vy = 0; // ceiling bonk
  if(showSweep){
    const a = new THREE.Vector3(prevX, prevY, player.position.z);
    sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, allowed)]);
  }
  return { dx, dy, hit:true };
}

// Drop-through (from your working patch)
function requestDropThrough(){
  if (grounded && lastGround && lastGround.userData.oneWay) {
    dropIgnoreObj = lastGround;
    dropTimer     = DROP_TIME;
    snapLock      = Math.max(snapLock, DROP_LOCK);
    grounded      = false;
    coyoteTimer   = 0;
    jumpBufferTimer = 0;
    vy            = Math.min(vy, -3.5);
    player.position.y -= 0.06;
  }
}

// === NEW: mover update + carry
function updateMovers(dt){
  for(const m of movers){
    const d = m.userData.mover;
    if(d.len <= 0){ d.delta.set(0,0); continue; }

    // save last center pos
    d.last.set(m.position.x, m.position.y);

    // advance param
    d.u += d.dir * (d.speed * dt / d.len);
    if(d.u > 1){ d.u = 1 - (d.u - 1); d.dir = -1; }
    if(d.u < 0){ d.u = -d.u;          d.dir =  1; }

    // lerp top position, then convert to center (topY - h/2)
    const topX = THREE.MathUtils.lerp(d.from.x, d.to.x, d.u);
    const topY = THREE.MathUtils.lerp(d.from.y, d.to.y, d.u);
    m.position.set(topX, topY - d.h*0.5, 0);

    // delta center this frame
    d.delta.set(m.position.x - d.last.x, m.position.y - d.last.y);
  }
}

// ---------------- Resize ----------------
addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateRig();
  const dz = dzBounds(0,0);
  updateDZHud(dz);
});

// ---------------- Main loop ----------------
const STIFF=60, DAMP=2*Math.sqrt(STIFF);
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  if(coyoteTimer>0) coyoteTimer -= dt;
  if(jumpBufferTimer>0) jumpBufferTimer -= dt;
  if(snapLock>0) snapLock -= dt;
  if(dropTimer>0) dropTimer -= dt;

  const ix = (input.right?1:0) - (input.left?1:0);

  // Timers for input gating
  if (downBuffer > 0) downBuffer -= dt;
  if (dropArmed  > 0) dropArmed  -= dt;

  // === NEW: move platforms first
  updateMovers(dt);

  // === NEW: if riding a mover, carry the player by the platform delta
  let carryX=0, carryY=0;
  if (grounded && lastGround && lastGround.userData.mover){
    const d = lastGround.userData.mover;
    carryX = d.delta.x; carryY = d.delta.y;
    player.position.x += carryX;
    player.position.y += carryY;
  }

  // If Jump+Down was armed, drop when grounded on one-way
  if (dropArmed > 0 && dropTimer <= 0 && grounded && lastGround && lastGround.userData.oneWay) {
    requestDropThrough();
    dropArmed = 0;
  }

  // Consume buffered jump (only if *not* dropping)
  if (jumpBufferTimer > 0
      && dropArmed <= 0
      && dropTimer <= 0
      && (grounded || coyoteTimer > 0)) {
    vy = JUMP_SPEED;
    grounded = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
    snapLock = SNAP_LOCK_AFTER_JUMP;
  }

  // extra gravity for short hops
  const extraG = (!jumpHeld && vy > 0) ? (JUMP_CUT_MULT * GRAVITY) : 0;

  // Intended step BEFORE applying it
  let stepX=0, stepY=0;
  if(grounded){
    coyoteTimer = COYOTE_TIME;
    if(ix !== 0){
      const t = new THREE.Vector3(groundNormal.y, -groundNormal.x, 0).normalize();
      if (t.x * ix < 0) t.multiplyScalar(-1);
      const speed = MOVE_SPEED * Math.abs(ix);
      stepX += t.x * speed * dt;
      stepY += t.y * speed * dt;
    }
  } else {
    vx = ix * AIR_SPEED;
    stepX += vx * dt;
    vy += (GRAVITY + extraG) * dt;
    stepY += vy * dt;
  }

  const prevX=player.position.x, prevY=player.position.y;
  const prevFeetY = prevY - PLAYER_HALF;

  // Walls/ceilings sweep
  const { dx, dy } = sweepCollide(prevX, prevY, stepX, stepY);
  player.position.x = prevX + dx;
  player.position.y = prevY + dy;

  // Downward snap (ground + one-way)
  const wasGrounded = grounded;
  snapToGround(prevFeetY);
  if(!grounded && wasGrounded && coyoteTimer<=0) coyoteTimer = COYOTE_TIME;

  // Follow & HUD
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;
  const dz = dzBounds(moveX, moveY);

  followCamera(dt);
  updateRig();
  updateDZHud(dz);

  hud.textContent =
    `L11 · Step 5 — grounded=${grounded} · vy=${vy.toFixed(2)} · carry=${carryX.toFixed(2)},${carryY.toFixed(2)} · ` +
    `slope=${grounded ? slopeDeg.toFixed(1)+'°' : '—'} · coyote=${Math.max(0,coyoteTimer).toFixed(2)} · buffer=${Math.max(0,jumpBufferTimer).toFixed(2)} · ` +
    `drop=${Math.max(0,dropTimer).toFixed(2)} · clamp=${clampEnabled?'on':'off'}`;

  renderer.render(scene, camera);

  lastPlayerX = player.position.x;
  lastPlayerY = player.position.y;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
