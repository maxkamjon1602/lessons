<!doctype html><meta charset="utf-8">
<title>Step 07 — rotate Y</title>
<style>
  html,body{margin:0;height:100%;background:#0f1117}
  canvas{display:block;width:100%;height:100%}
  #controls{position:absolute;top:10px;left:10px;display:flex;gap:12px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:8px;color:#e6e6e6;font:14px system-ui}
  button{background:#1a1d2b;color:#e6e6e6;border:1px solid #444;border-radius:6px;padding:4px 10px;cursor:pointer}
.overlay{position:fixed;top:8px;right:8px;padding:6px 10px;background:rgba(0,0,0,0.55);border-radius:8px;color:#fff;font:14px monospace;}</style>
<div id="controls">
  <label><input id="cb-square" type="checkbox"> Square</label>
  <label><input id="cb-triangle" type="checkbox"> Triangle</label>
  <button id="btn-rotate-z">Rotate Z: OFF</button>
  <button id="btn-rotate-y">Rotate Y: OFF</button>
</div>
<canvas id="c"></canvas>
<div class="overlay">Lesson 01 · Step 7/7 — rotate Y</div>
<script type="module">
// SPDX-License-Identifier: LicenseRef-UT-PEL-1.0
// Copyright (c) 2025 UZ Learn Try. All rights reserved.


  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  const canvas=document.getElementById('c');
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setClearColor(0x0f1117,1);
  const scene=new THREE.Scene(); let cam=makeOrtho();

  function makeOrtho(){ const w=renderer.domElement.clientWidth,h=renderer.domElement.clientHeight;
    const c=new THREE.OrthographicCamera(0,w,0,h,-500,500); c.position.z=200; c.updateProjectionMatrix(); return c; }

  function addSquare(x,y,size,color){ const g=new THREE.PlaneGeometry(size,size);
    const m=new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(g,m); mesh.position.set(x+size/2,y+size/2,0); mesh.visible=false; scene.add(mesh); return mesh; }
  function addTriangle(x,y,w,h,color){ const s=new THREE.Shape(); s.moveTo(w/2,0); s.lineTo(0,h); s.lineTo(w,h); s.closePath();
    const g=new THREE.ShapeGeometry(s);
    const m=new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(g,m); mesh.position.set(x,y,0); mesh.visible=false; scene.add(mesh); return mesh; }

  const square=addSquare(80,100,120,0xffffff);
  const triangle=addTriangle(240,100,140,120,0x00ccff);

  const cbS=document.getElementById('cb-square'); const cbT=document.getElementById('cb-triangle');
  cbS.addEventListener('change', ()=> square.visible=cbS.checked);
  cbT.addEventListener('change', ()=> triangle.visible=cbT.checked);
  cbS.checked=cbT.checked=true; cbS.dispatchEvent(new Event('change')); cbT.dispatchEvent(new Event('change'));

  let rotatingZ=false, rotatingY=false;
  const btnZ=document.getElementById('btn-rotate-z');
  const btnY=document.getElementById('btn-rotate-y');
  btnZ.addEventListener('click', ()=>{ rotatingZ=!rotatingZ; btnZ.textContent=`Rotate Z: ${rotatingZ?'ON':'OFF'}`; });
  btnY.addEventListener('click', ()=>{ rotatingY=!rotatingY; btnY.textContent=`Rotate Y: ${rotatingY?'ON':'OFF'}`; });

  function tick(){
    const need=canvas.width!==Math.floor(canvas.clientWidth*devicePixelRatio)||
               canvas.height!==Math.floor(canvas.clientHeight*devicePixelRatio);
    if(need){ renderer.setSize(canvas.clientWidth, canvas.clientHeight, false); cam=makeOrtho(); }
    if(rotatingZ){ square.rotation.z+=0.01; triangle.rotation.z+=0.01; }
    if(rotatingY){ square.rotation.y+=0.01; triangle.rotation.y+=0.01; }
    renderer.render(scene, cam); requestAnimationFrame(tick);
  } requestAnimationFrame(tick);
</script>
