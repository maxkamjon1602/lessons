<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>uz learn try â€” Lesson 01</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { margin:0; height:100%; background:#0f1117; }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      display: flex; gap: 12px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 8px;
      font-family: system-ui, sans-serif;
      color: #e6e6e6; font-size: 14px;
      z-index: 1;
    }
    #controls label { cursor:pointer; }
    #controls button {
      background: #1a1d2b; color: #e6e6e6;
      border: 1px solid #444; border-radius: 6px;
      padding: 4px 10px; cursor: pointer;
    }
    #controls button:hover { background:#2d3144; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="controls">
    <label><input id="cb-square" type="checkbox"> Square</label>
    <label><input id="cb-triangle" type="checkbox"> Triangle</label>
    <button id="btn-rotate-z">Rotate Z: OFF</button>
    <button id="btn-rotate-y">Rotate Y: OFF</button>
  </div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas   = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x0f1117, 1);

    const scene = new THREE.Scene();

    let cam = makeOrtho();
    function makeOrtho() {
      const w = renderer.domElement.clientWidth;
      const h = renderer.domElement.clientHeight;
      const cam = new THREE.OrthographicCamera(0, w, 0, h, -500, 500);
      cam.position.z = 200;
      cam.updateProjectionMatrix();
      return cam;
    }

    function addSquare(x, y, size, color) {
      const geo = new THREE.PlaneGeometry(size, size);
      const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(x + size / 2, y + size / 2, 0);
      m.visible = false;
      scene.add(m);
      return m;
    }

    function addTriangle(x, y, w, h, color) {
      const s = new THREE.Shape();
      s.moveTo(w/2, 0); s.lineTo(0, h); s.lineTo(w, h); s.closePath();
      const geo = new THREE.ShapeGeometry(s);
      const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(x, y, 0);
      m.visible = false;
      scene.add(m);
      return m;
    }

    const square   = addSquare(80, 80, 120, 0xffffff);
    const triangle = addTriangle(240, 100, 140, 120, 0x00ccff);

    function resizeRendererToDisplaySize() {
      const need =
        canvas.width  !== Math.floor(canvas.clientWidth  * devicePixelRatio) ||
        canvas.height !== Math.floor(canvas.clientHeight * devicePixelRatio);
      if (need) {
        renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
        cam = makeOrtho();
      }
    }

    let rotatingZ = false;
    let rotatingY = false;

    const btnZ = document.getElementById('btn-rotate-z');
    btnZ.addEventListener('click', () => {
      rotatingZ = !rotatingZ;
      btnZ.textContent = `Rotate Z: ${rotatingZ ? "ON" : "OFF"}`;
    });

    const btnY = document.getElementById('btn-rotate-y');
    btnY.addEventListener('click', () => {
      rotatingY = !rotatingY;
      btnY.textContent = `Rotate Y: ${rotatingY ? "ON" : "OFF"}`;
    });

    function tick() {
      resizeRendererToDisplaySize();

      if (rotatingZ) { square.rotation.z += 0.01; triangle.rotation.z += 0.01; }
      if (rotatingY) { square.rotation.y += 0.01; triangle.rotation.y += 0.01; }

      renderer.render(scene, cam);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    const cbSquare   = document.getElementById('cb-square');
    const cbTriangle = document.getElementById('cb-triangle');

    cbSquare.addEventListener('change', () => { square.visible = cbSquare.checked; });
    cbTriangle.addEventListener('change', () => { triangle.visible = cbTriangle.checked; });

    cbSquare.checked = true;   cbSquare.dispatchEvent(new Event('change'));
    cbTriangle.checked = true; cbTriangle.dispatchEvent(new Event('change'));

    addEventListener('resize', resizeRendererToDisplaySize);
  </script>
</body>
</html>
