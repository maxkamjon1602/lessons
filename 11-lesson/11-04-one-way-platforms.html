<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 11 · Step 4 — One-Way Platforms (Edge-Aware DZ + Fixes)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#131722}
  #app{width:100%;height:100%}
  .hud{position:fixed;top:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.55);color:#fff;font:13px/1.35 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.45);color:#fff;font:12px/1.35 monospace}
  /* DZ is positioned by JS (no center transform) */
  #dz{position:fixed;left:0;top:0;pointer-events:none;border:2px solid rgba(255,255,255,.85)}
</style>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="hud" class="hud">
  L11 · Step 4 — grounded=false · vy=0.00 · slope=— · coyote=0.00 · buffer=0.00 · drop=0.00 · clamp=on
</div>
<div id="dz"></div>
<div class="help">
  Move: <b>A/D</b> · Jump: <b>Space/W/↑</b> · <b>Down+Jump</b> drops through <u>one-way</u> only · Rays: <b>G</b> · Sweep: <b>C</b> · Wireframe: <b>H</b> · Reset: <b>R</b><br/>
  Parallax: <b>1/2/3/4</b> · <b>M</b> clamp on/off · Bounds: <b>B</b> · Ortho/Persp: <b>P</b> · PPU: <b>K</b>/<b>L</b>
</div>

<script type="module">
const THREE = await import('three');

const app  = document.getElementById('app');
const hud  = document.getElementById('hud');
const dzEl = document.getElementById('dz');

// ---------------- Renderer ----------------
const renderer = new THREE.WebGLRenderer({ antialias:true });
app.appendChild(renderer.domElement);
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x131722);
if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

// ---------------- Scene & Layers ----------------
const scene = new THREE.Scene();
const bg  = new THREE.Group();  bg.userData.parallax  = 0.25;
const mid = new THREE.Group();  mid.userData.parallax = 1.00;
const fg  = new THREE.Group();  fg.userData.parallax  = 1.50;
bg.position.z=-10; mid.position.z=0; fg.position.z=10;
scene.add(bg, mid, fg);

// Sky gradient (brighter)
const skyMat = new THREE.ShaderMaterial({
  uniforms:{ top:{value:new THREE.Color(0x334a7a)}, bottom:{value:new THREE.Color(0x1a2336)} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`uniform vec3 top; uniform vec3 bottom; varying vec2 vUv;
    void main(){ vec3 c = mix(bottom, top, clamp(vUv.y,0.0,1.0)); gl_FragColor=vec4(c,1.0); }`
});
skyMat.depthWrite=false; skyMat.depthTest=false;
const sky = new THREE.Mesh(new THREE.PlaneGeometry(1,1), skyMat);
sky.renderOrder = -100; bg.add(sky);

// ---------------- Level geometry ----------------
const LEVEL_Z = -0.05;       // ground slightly behind player
const THICK   = 0.30;        // thin Z so nothing occludes player
const groundMat = new THREE.MeshStandardMaterial({ color:0x2e3758, roughness:0.9 });
const rampMat   = new THREE.MeshStandardMaterial({ color:0x3a5b8f, roughness:0.85 });
const oneWayMat = new THREE.MeshStandardMaterial({ color:0x7d5cff, roughness:0.6, emissive:0x171133, emissiveIntensity:0.25 });

let groundWireframe=false;
function setWireframe(on){ groundMat.wireframe=on; rampMat.wireframe=on; oneWayMat.wireframe=on; }

const level = new THREE.Group(); level.position.z = LEVEL_Z; mid.add(level);

function flat(w, y=-1, x=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,0.5,THICK), groundMat);
  m.position.set(x,y-0.25,0); m.receiveShadow=true; return m;
}
// Triangular wedge ramp (no giant rotated box)
function ramp(w, h, x=0, y=-1, up=true){
  const s = new THREE.Shape();
  if (up){ s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(w/2,h); }
  else   { s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(-w/2,h); }
  s.closePath();
  const geo = new THREE.ExtrudeGeometry(s, { depth: THICK, bevelEnabled:false });
  geo.translate(0,0,-THICK/2); // center on z=0
  const m = new THREE.Mesh(geo, rampMat);
  m.position.set(x,y,0); m.receiveShadow=true; return m;
}
function oneWay(w=4, x=0, y=1.2){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.18, THICK*0.7), oneWayMat);
  m.position.set(x, y, 0);
  m.userData.oneWay = true;
  return m;
}
// Course
level.add(flat(12,-1, -12));
level.add(ramp(8,3, -1,-1, true));
level.add(flat(10, 0.5, 8));
level.add(ramp(6,-2, 14,0.5, false));
level.add(flat(12,-1, 23));
level.add(oneWay(4, 5.5, 1.1));
level.add(oneWay(5, 18.0, 2.3));

// ---------------- Lights ----------------
scene.add(new THREE.HemisphereLight(0x9fb8ff, 0x1b2030, 0.65));
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const dir = new THREE.DirectionalLight(0xffffff,1.25); dir.position.set(6,10,6); scene.add(dir);

// ---------------- Camera rig (ortho + clamp) ----------------
let PIXELS_PER_UNIT=64; const MIN_PPU=16, MAX_PPU=256;
const aspect = ()=> window.innerWidth / window.innerHeight;

const ortho = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
ortho.position.set(0,0,10); ortho.lookAt(0,0,0);

const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
let perspDist=10; persp.position.set(0,0,perspDist); persp.lookAt(0,0,0);

let usingOrtho=true; let camera=ortho;
let camX=0, camY=0, camVX=0, camVY=0;

const WORLD = { minX:-14, maxX:26, minY:-4, maxY:8 };
let clampEnabled = true; // toggled with 'M'

function visibleUnitsOrtho(){ const halfH=(window.innerHeight/PIXELS_PER_UNIT)*0.5; return [halfH*aspect(), halfH]; }
function visibleUnitsPersp(){ const halfH=Math.tan((Math.PI/180)*(persp.fov*0.5))*perspDist; return [halfH*aspect(), halfH]; }
function visibleUnits(){ return usingOrtho?visibleUnitsOrtho():visibleUnitsPersp(); }
function sizeSky(){ const [halfW,halfH]=visibleUnits(); sky.scale.set(halfW*4,halfH*2,1); }

function updateOrtho(){
  const [halfW,halfH]=visibleUnitsOrtho();
  ortho.left=-halfW+camX; ortho.right=halfW+camX; ortho.top=halfH+camY; ortho.bottom=-halfH+camY;
  ortho.updateProjectionMatrix();
  ortho.position.set(camX,camY,10); ortho.lookAt(camX,camY,0);
  sizeSky();
}
function updatePersp(){
  persp.aspect=aspect(); persp.updateProjectionMatrix();
  persp.position.set(camX,camY,perspDist); persp.lookAt(camX,camY,0);
  sizeSky();
}
function clampToWorld(cx, cy){
  const [halfW, halfH] = visibleUnits();
  const minX = WORLD.minX + halfW, maxX = WORLD.maxX - halfW;
  const minY = WORLD.minY + halfH, maxY = WORLD.maxY - halfH;
  const worldW=WORLD.maxX-WORLD.minX, worldH=WORLD.maxY-WORLD.minY;
  const viewW=halfW*2, viewH=halfH*2;
  return [
    (viewW>=worldW)?(WORLD.minX+WORLD.maxX)/2:THREE.MathUtils.clamp(cx,minX,maxX),
    (viewH>=worldH)?(WORLD.minY+WORLD.maxY)/2:THREE.MathUtils.clamp(cy,minY,maxY)
  ];
}

// -------- Edge-aware + direction-aware dead-zone --------
let DZ_W=0.40, DZ_H=0.30;
const EPS = 1e-3;

function dzBounds(moveX=0, moveY=0){
  const [halfW, halfH] = visibleUnits();
  const viewL = camX - halfW, viewR = camX + halfW;
  const viewB = camY - halfH, viewT = camY + halfH;

  // If clamping is OFF, keep centered DZ always.
  if(!clampEnabled){
    const dzHalfW = halfW * DZ_W, dzHalfH = halfH * DZ_H;
    return { left:camX-dzHalfW, right:camX+dzHalfW, bottom:camY-dzHalfH, top:camY+dzHalfH,
             halfW, halfH, viewL, viewB };
  }

  const atL = Math.abs(camX - (WORLD.minX + halfW)) <= EPS;
  const atR = Math.abs(camX - (WORLD.maxX - halfW)) <= EPS;
  const atB = Math.abs(camY - (WORLD.minY + halfH)) <= EPS;
  const atT = Math.abs(camY - (WORLD.maxY - halfH)) <= EPS;

  const dzHalfW = halfW * DZ_W;
  const dzHalfH = halfH * DZ_H;

  let left   = camX - dzHalfW, right  = camX + dzHalfW;
  let bottom = camY - dzHalfH, top    = camY + dzHalfH;

  // Anchor only when moving INTO the clamped edge; otherwise stay centered for quick release.
  if (atL && moveX < -0.001) { left  = viewL; right = Math.min(viewL + 2*dzHalfW, viewR); }
  if (atR && moveX >  0.001) { right = viewR; left  = Math.max(viewR - 2*dzHalfW, viewL); }
  if (atB && moveY < -0.001) { bottom= viewB; top   = Math.min(viewB + 2*dzHalfH, viewT); }
  if (atT && moveY >  0.001) { top   = viewT; bottom= Math.max(viewT - 2*dzHalfH, viewB); }

  return { left, right, bottom, top, halfW, halfH, viewL, viewB };
}
function updateDZHud(dz){
  const pxW = ((dz.right  - dz.left)   / (2*dz.halfW)) * innerWidth;
  const pxH = ((dz.top    - dz.bottom) / (2*dz.halfH)) * innerHeight;
  const pxX = ((dz.left   - dz.viewL)  / (2*dz.halfW)) * innerWidth;
  const pxY = ((dz.bottom - dz.viewB)  / (2*dz.halfH)) * innerHeight;
  dzEl.style.width  = Math.round(pxW) + 'px';
  dzEl.style.height = Math.round(pxH) + 'px';
  dzEl.style.left   = Math.round(pxX) + 'px';
  dzEl.style.top    = Math.round(pxY) + 'px';
}
// Direction-aware, edge-aware camera follow.
// Uses lastPlayerX/Y to know which way the player is moving.
function followCamera(dt){
  // player movement this frame
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;

  // dead-zone anchored to edges only when pushing into them
  const dz = dzBounds(moveX, moveY);

  let shiftX = 0, shiftY = 0;
  if (player.position.x < dz.left)   shiftX = player.position.x - dz.left;
  if (player.position.x > dz.right)  shiftX = player.position.x - dz.right;
  if (player.position.y < dz.bottom) shiftY = player.position.y - dz.bottom;
  if (player.position.y > dz.top)    shiftY = player.position.y - dz.top;

  // target camera center
  let targetX = camX + shiftX;
  let targetY = camY + shiftY;
  if (clampEnabled) [targetX, targetY] = clampToWorld(targetX, targetY);

  // critically damped spring to target
  const ax = STIFF * (targetX - camX) - DAMP * camVX;
  const ay = STIFF * (targetY - camY) - DAMP * camVY;
  camVX += ax * dt;  camVY += ay * dt;
  camX  += camVX * dt; camY  += camVY * dt;
}


function applyParallax(){
  const set=(g,f)=>{ g.position.x = camX*(1-f); g.position.y = camY*(1-f); };
  set(bg, bg.userData.parallax); set(mid, mid.userData.parallax); set(fg, fg.userData.parallax);
}
function updateRig(){
  if(usingOrtho){ camera=ortho; updateOrtho(); } else { camera=persp; updatePersp(); }
  applyParallax();
}

// ---------------- Player controller (with one-way) ----------------
const PLAYER_HEIGHT=1.1, PLAYER_HALF=PLAYER_HEIGHT*0.5, PLAYER_WIDTH=0.8;
const MOVE_SPEED=6.0, AIR_SPEED=5.0;     // conservative feel
const GRAVITY=-18.0;
const JUMP_SPEED=8.5;
const JUMP_CUT_MULT=2.4;
const SNAP_DIST=0.35, MAX_SLOPE_DEG=38;
const COYOTE_TIME=0.12, JUMP_BUFFER=0.12;
const SNAP_LOCK_AFTER_JUMP=0.06;
const SKIN=0.02, RADIUS=PLAYER_WIDTH*0.5;

// --- Drop-through input gating ---
const DOWN_BUFFER = 0.20;      // seconds: tap-Down within this window + Jump also counts
const DROP_ARM_TIME = 0.25;    // seconds: after Jump+Down, we wait to be grounded to execute drop

let downBuffer = 0;            // time left since last Down press
let dropArmed  = 0;            // time left to perform the drop when grounded

const DROP_TIME=0.25, DROP_LOCK=0.08;
let dropIgnoreObj=null, dropTimer=0;

const player = new THREE.Mesh(
  new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, 0.8),
  new THREE.MeshStandardMaterial({ color:0x88ff88, emissive:0x224422, emissiveIntensity:0.12 })
);
player.position.set(-12,-0.2,+0.05); // slight +Z so terrain never covers it
mid.add(player);

let lastPlayerX = player.position.x, lastPlayerY = player.position.y;

const raycaster = new THREE.Raycaster();
const UP = new THREE.Vector3(0,1,0);
let grounded=false, slopeDeg=0, groundNormal=new THREE.Vector3(0,1,0), lastGround=null;
let vx=0, vy=0, coyoteTimer=0, jumpBufferTimer=0, snapLock=0;
let jumpHeld=false, downHeld=false;

const colliders=[]; level.traverse(o=>{ if(o.isMesh) colliders.push(o); });

// Debug viz
const rayViz = new THREE.Group(); mid.add(rayViz);
const rayDown = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,-1,0)]), new THREE.LineBasicMaterial({ color:0x66ccff }));
const rayNormal = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,1,0)]), new THREE.LineBasicMaterial({ color:0xffaa00 }));
const sweepViz = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(1,0,0)]), new THREE.LineBasicMaterial({ color:0xff66ff }));
rayViz.add(rayDown, rayNormal, sweepViz);
let showRay=true, showSweep=false;

// Input
// Input
const input = { left:false, right:false };

addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();

  if (k==='a' || k==='arrowleft')  input.left  = true;
  if (k==='d' || k==='arrowright') input.right = true;

  if (k==='s' || k==='arrowdown') {
    downHeld    = true;
    downBuffer  = DOWN_BUFFER;          // remember a quick Down tap
  }

  if (k==='w' || k==='arrowup' || k===' ') {
    // JUMP: buffer jump as before
    jumpHeld        = true;
    jumpBufferTimer = JUMP_BUFFER;

    // 🔑 NEW: Arm drop (don’t execute yet). Works with hold-Down OR tap-Down.
    if (downHeld || downBuffer > 0) dropArmed = DROP_ARM_TIME;
  }

  if (k==='g') { showRay = !showRay; rayDown.visible = rayNormal.visible = showRay; }
  if (k==='c') { showSweep = !showSweep; sweepViz.visible = showSweep; }
  if (k==='h') { groundWireframe = !groundWireframe; setWireframe(groundWireframe); }
  if (k==='r') { player.position.set(-12,-0.2,+0.05); vx=vy=0; coyoteTimer=jumpBufferTimer=snapLock=dropTimer=0; lastGround=null; }
  if (k==='p') { usingOrtho = !usingOrtho; updateRig(); }
  if (k==='m') { clampEnabled = !clampEnabled; }
  if (k==='1') { bg.userData.parallax=0.40; mid.userData.parallax=1.00; fg.userData.parallax=1.20; }
  if (k==='2') { bg.userData.parallax=0.25; mid.userData.parallax=1.00; fg.userData.parallax=1.50; }
  if (k==='3') { bg.userData.parallax=0.10; mid.userData.parallax=1.00; fg.userData.parallax=1.60; }
  if (k==='4') { bg.userData.parallax=0.05; mid.userData.parallax=1.00; fg.userData.parallax=1.80; }
  if (k==='k') setPPU(PIXELS_PER_UNIT-4);
  if (k==='l') setPPU(PIXELS_PER_UNIT+4);
  if (k==='b') { bounds.visible = !bounds.visible; }
});

addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();

  if (k==='a' || k==='arrowleft')  input.left  = false;
  if (k==='d' || k==='arrowright') input.right = false;

  if (k==='s' || k==='arrowdown')  downHeld    = false;

  if (k==='w' || k==='arrowup' || k===' ') {
    // Key released → we are no longer “holding jump”
    jumpHeld = false;
    // (Do NOT arm drop or set jumpBuffer here.)
  }
});

function setPPU(ppu){ PIXELS_PER_UNIT=THREE.MathUtils.clamp(ppu,MIN_PPU,MAX_PPU); }

// World bounds overlay
const bounds = new THREE.LineSegments((()=>{
  const g=new THREE.BufferGeometry();
  const p=new Float32Array([
    WORLD.minX,WORLD.minY,0, WORLD.maxX,WORLD.minY,0,
    WORLD.maxX,WORLD.minY,0, WORLD.maxX,WORLD.maxY,0,
    WORLD.maxX,WORLD.maxY,0, WORLD.minX,WORLD.maxY,0,
    WORLD.minX,WORLD.maxY,0, WORLD.minX,WORLD.minY,0
  ]);
  g.setAttribute('position', new THREE.BufferAttribute(p,3));
  return g;
})(), new THREE.LineBasicMaterial({ color:0x00ff99 }));
bounds.position.z = 0.01; bounds.visible=false; mid.add(bounds);

// -------- Ground snap (with one-way rules) --------
const normalMat = new THREE.Matrix3();
function snapToGround(prevFeetY){
  if(snapLock>0) { grounded=false; return; } // ignore soon after jump/drop
  grounded=false; slopeDeg=0;

  const origin = new THREE.Vector3(player.position.x, player.position.y - PLAYER_HALF + 0.05, player.position.z);
  const dir = new THREE.Vector3(0,-1,0);
  raycaster.set(origin, dir); raycaster.far = SNAP_DIST + 0.2;

  const hits = raycaster.intersectObjects(colliders, false);
  if(!hits.length){
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
    return;
  }

  for(const h of hits){
    if(!h.face) continue;
    const isOneWay = !!h.object.userData.oneWay;

    normalMat.getNormalMatrix(h.object.matrixWorld);
    const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();
    if(n.y <= 0.45) continue; // must be ground-ish

    const topY = h.point.y;
    const dy = origin.y - h.point.y;

    if(isOneWay){
      if(vy > 0) continue;                    // rising: pass through
      if(prevFeetY < topY - 0.01) continue;   // coming from below: pass through
      if(dropTimer > 0 && dropIgnoreObj === h.object) continue; // active drop-through
    }

    const angle = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(n.dot(UP),-1,1)));
    if(dy >= -0.02 && dy <= SNAP_DIST && angle <= MAX_SLOPE_DEG){
      player.position.y = topY + PLAYER_HALF;
      vy = 0; grounded=true; groundNormal.copy(n); lastGround=h.object;

      rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
      rayNormal.geometry.setFromPoints([h.point, h.point.clone().addScaledVector(n, 1.0)]);
      break;
    }
  }
}

// -------- Sweep collision (walls/ceilings only; ignore ground & one-way) --------
function sweepCollide(prevX, prevY, stepX, stepY){
  const dist = Math.hypot(stepX, stepY);
  if(dist <= 1e-6) return { dx:0, dy:0, hit:false };

  const dir = new THREE.Vector3(stepX/dist, stepY/dist, 0);
  const yFeet = prevY - PLAYER_HALF + 0.05;
  const yMid  = prevY;
  const yHead = prevY + PLAYER_HALF - 0.05;
  const origins = [
    new THREE.Vector3(prevX, yFeet, player.position.z),
    new THREE.Vector3(prevX, yMid,  player.position.z),
    new THREE.Vector3(prevX, yHead, player.position.z),
  ];

  const far = dist + RADIUS + SKIN; raycaster.far = far;
  let minHit = Infinity, best=null;

  for(const o of origins){
    raycaster.set(o, dir);
    const hits = raycaster.intersectObjects(colliders, false);
    if(!hits.length) continue;

    for(const h of hits){
      if(!h.face) continue;
      if(h.object.userData.oneWay) continue; // skip one-way entirely in sweep

      normalMat.getNormalMatrix(h.object.matrixWorld);
      const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();

      if(stepY < 0 && n.y > 0.45) continue;  // ignore ground while falling; snap handles it
      if(n.dot(dir) < -0.2 && h.distance < minHit){ // opposing face
        minHit = h.distance; best = { normal:n, point:h.point.clone() };
      }
      break; // nearest-first
    }
  }

  if(!best){
    if(showSweep){
      const a = new THREE.Vector3(prevX, prevY, player.position.z);
      sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, dist)]);
    }
    return { dx:stepX, dy:stepY, hit:false };
  }

  const allowed = Math.max(0, minHit - (RADIUS + SKIN));
  const dx = dir.x * allowed, dy = dir.y * allowed;
  if(stepY > 0 && best.normal.y < -0.3) vy = 0; // ceiling bonk
  if(showSweep){
    const a = new THREE.Vector3(prevX, prevY, player.position.z);
    sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, allowed)]);
  }
  return { dx, dy, hit:true };
}

function requestDropThrough(){
  if (grounded && lastGround && lastGround.userData.oneWay) {
    dropIgnoreObj = lastGround;
    dropTimer = DROP_TIME;            // temporarily ignore this platform
    snapLock  = Math.max(snapLock, DROP_LOCK);
    grounded  = false;
    vy        = Math.min(vy, -3.5);   // stronger downward nudge so we clear it
    player.position.y -= 0.06;        // tiny offset to exit the top face
  }
}


// ---------------- Resize ----------------
addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateRig();                     // camera/parallax
  const dz = dzBounds(0,0);        // neutral movement for HUD on resize
  updateDZHud(dz);
});

// ---------------- Main loop ----------------
const STIFF=60, DAMP=2*Math.sqrt(STIFF);
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  if(coyoteTimer>0) coyoteTimer -= dt;
  if(jumpBufferTimer>0) jumpBufferTimer -= dt;
  if(snapLock>0) snapLock -= dt;
  if(dropTimer>0) dropTimer -= dt;

  const ix = (input.right?1:0) - (input.left?1:0);

  // Timers for input gating
  if (downBuffer > 0) downBuffer -= dt;
  if (dropArmed  > 0) dropArmed  -= dt;

  // If Jump+Down was armed, execute drop the next moment we're grounded on a one-way
  if (dropArmed > 0 && dropTimer <= 0 && grounded && lastGround && lastGround.userData.oneWay) {
    requestDropThrough();   // performs the actual ignore + nudge
    dropArmed = 0;          // consume the arm
  }

  // Consume buffered jump (grounded or within coyote)
  if(jumpBufferTimer>0 && (grounded || coyoteTimer>0)){
    vy = JUMP_SPEED;
    grounded = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
    snapLock = SNAP_LOCK_AFTER_JUMP;
  }

  // extra gravity for short hops
  const extraG = (!jumpHeld && vy > 0) ? (JUMP_CUT_MULT * GRAVITY) : 0;

  // Intended step BEFORE applying it
  let stepX=0, stepY=0;
  if(grounded){
    coyoteTimer = COYOTE_TIME;
    if(ix !== 0){
      const t = new THREE.Vector3(groundNormal.y, -groundNormal.x, 0).normalize();
      if (t.x * ix < 0) t.multiplyScalar(-1);
      const speed = MOVE_SPEED * Math.abs(ix);
      stepX += t.x * speed * dt;
      stepY += t.y * speed * dt;
    }
  } else {
    vx = ix * AIR_SPEED;
    stepX += vx * dt;
    vy += (GRAVITY + extraG) * dt;
    stepY += vy * dt;
  }

  const prevX=player.position.x, prevY=player.position.y;
  const prevFeetY = prevY - PLAYER_HALF;

  // Walls/ceilings sweep
  const { dx, dy } = sweepCollide(prevX, prevY, stepX, stepY);
  player.position.x = prevX + dx;
  player.position.y = prevY + dy;

  // Downward snap (ground + one-way)
  const wasGrounded = grounded;
  snapToGround(prevFeetY);
  if(!grounded && wasGrounded && coyoteTimer<=0) coyoteTimer = COYOTE_TIME;

  // Direction-aware DZ: use actual player movement this frame
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;
  const dz = dzBounds(moveX, moveY);

  // Follow & render
  followCamera(dt);
  updateRig();
  updateDZHud(dz);

  hud.textContent =
    `L11 · Step 4 — grounded=${grounded} · vy=${vy.toFixed(2)} · slope=${grounded ? slopeDeg.toFixed(1)+'°' : '—'} · ` +
    `coyote=${Math.max(0,coyoteTimer).toFixed(2)} · buffer=${Math.max(0,jumpBufferTimer).toFixed(2)} · ` +
    `drop=${Math.max(0,dropTimer).toFixed(2)} · clamp=${clampEnabled?'on':'off'} · ` +
    `down=${downHeld} · onOneWay=${!!(lastGround && lastGround.userData.oneWay)} 
    · down=${downHeld} · dbuf=${downBuffer.toFixed(2)} · armed=${dropArmed.toFixed(2)}`;


  renderer.render(scene, camera);

  lastPlayerX = player.position.x;
  lastPlayerY = player.position.y;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
