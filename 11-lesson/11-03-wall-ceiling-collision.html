<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 11 · Step 3 — Walls & Ceilings (swept collision)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#131722}
  #app{width:100%;height:100%}
  .hud{position:fixed;top:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.55);color:#fff;font:13px/1.35 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.45);color:#fff;font:12px/1.35 monospace}
  #dz{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;border:2px solid rgba(255,255,255,.85)}
</style>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="hud" class="hud">L11 · Step 3 — grounded=false · vy=0.00 · slope=— · coyote=0.00 · buffer=0.00</div>
<div id="dz"></div>
<div class="help">
  Move: <b>A/D</b> · Jump: <b>Space/W/↑</b> · Rays: <b>G</b> · Wireframe: <b>H</b> · Reset: <b>R</b><br/>
  Parallax: <b>1/2/3/4</b> · Clamp: <b>M</b> · Bounds: <b>B</b> · Ortho/Persp: <b>P</b> · PPU: <b>K</b>/<b>L</b> · Collision rays: <b>C</b>
</div>

<script type="module">
const THREE = await import('three');

const app = document.getElementById('app');
const hud = document.getElementById('hud');
const dzEl = document.getElementById('dz');

// ---------- Renderer ----------
const renderer = new THREE.WebGLRenderer({ antialias:true });
app.appendChild(renderer.domElement);
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x131722);
if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

// ---------- Scene & Layers ----------
const scene = new THREE.Scene();
const bg  = new THREE.Group();  bg.userData.parallax  = 0.25;
const mid = new THREE.Group();  mid.userData.parallax = 1.00;
const fg  = new THREE.Group();  fg.userData.parallax  = 1.50;
bg.position.z=-10; mid.position.z=0; fg.position.z=10;
scene.add(bg, mid, fg);

// Sky gradient (bright)
const skyMat = new THREE.ShaderMaterial({
  uniforms:{ top:{value:new THREE.Color(0x334a7a)}, bottom:{value:new THREE.Color(0x1a2336)} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`uniform vec3 top; uniform vec3 bottom; varying vec2 vUv;
    void main(){ vec3 c = mix(bottom, top, clamp(vUv.y,0.0,1.0)); gl_FragColor=vec4(c,1.0); }`
});
skyMat.depthWrite=false; skyMat.depthTest=false;
const sky = new THREE.Mesh(new THREE.PlaneGeometry(1,1), skyMat);
sky.renderOrder = -100; bg.add(sky);

// ---------- Level geometry (thin & bright) ----------
const LEVEL_Z = -0.05;
const GROUND_Z_THICK = 0.30;
const groundMat = new THREE.MeshStandardMaterial({ color:0x2e3758, roughness:0.9 });
const rampMat   = new THREE.MeshStandardMaterial({ color:0x3a5b8f, roughness:0.85 });

let groundWireframe=false;
function setWireframe(on){ groundMat.wireframe=on; rampMat.wireframe=on; }

const level = new THREE.Group(); level.position.z = LEVEL_Z; mid.add(level);

function flat(w, y=-1, x=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,0.5,GROUND_Z_THICK), groundMat);
  m.position.set(x,y-0.25,0); m.receiveShadow=true; return m;
}
function ramp(w, h, x=0, y=-1, up=true){
  const box = new THREE.Mesh(new THREE.BoxGeometry(w, Math.hypot(w,h), GROUND_Z_THICK), rampMat);
  box.position.set(x, y + h*0.5, 0);
  box.rotation.z = Math.atan2(h, w) * (up?1:-1);
  return box;
}
// Course
level.add(flat(12,-1, -12));
level.add(ramp(8,3, -1,-1, true));
level.add(flat(10, 0.5, 8));
level.add(ramp(6,-2, 14,0.5, false));
level.add(flat(12,-1, 23));

// ---------- Lights ----------
scene.add(new THREE.HemisphereLight(0x9fb8ff, 0x1b2030, 0.65));
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const dir = new THREE.DirectionalLight(0xffffff,1.25); dir.position.set(6,10,6); scene.add(dir);

// ---------- Camera (ortho + follow + clamp) ----------
let PIXELS_PER_UNIT=64; const MIN_PPU=16, MAX_PPU=256;
const aspect = ()=> window.innerWidth / window.innerHeight;

const ortho = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
ortho.position.set(0,0,10); ortho.lookAt(0,0,0);

const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
let perspDist=10; persp.position.set(0,0,perspDist); persp.lookAt(0,0,0);

let usingOrtho=true; let camera=ortho;

let camX=0, camY=0, camVX=0, camVY=0;
let DZ_W=0.40, DZ_H=0.30;
function updateDZ(){ dzEl.style.width=Math.round(window.innerWidth*DZ_W)+'px'; dzEl.style.height=Math.round(window.innerHeight*DZ_H)+'px'; }
updateDZ();

const WORLD = { minX:-14, maxX:26, minY:-4, maxY:8 };
let clampEnabled = true;

function visibleUnitsOrtho(){ const halfH=(window.innerHeight/PIXELS_PER_UNIT)*0.5; return [halfH*aspect(), halfH]; }
function visibleUnitsPersp(){ const halfH=Math.tan((Math.PI/180)*(persp.fov*0.5))*perspDist; return [halfH*aspect(), halfH]; }
function visibleUnits(){ return usingOrtho?visibleUnitsOrtho():visibleUnitsPersp(); }
function sizeSky(){ const [halfW,halfH]=visibleUnits(); sky.scale.set(halfW*4,halfH*2,1); }

function updateOrtho(){
  const [halfW,halfH]=visibleUnitsOrtho();
  ortho.left=-halfW+camX; ortho.right=halfW+camX; ortho.top=halfH+camY; ortho.bottom=-halfH+camY;
  ortho.updateProjectionMatrix();
  ortho.position.set(camX,camY,10); ortho.lookAt(camX,camY,0);
  sizeSky();
}
function updatePersp(){
  persp.aspect=aspect(); persp.updateProjectionMatrix();
  persp.position.set(camX,camY,perspDist); persp.lookAt(camX,camY,0);
  sizeSky();
}
function clampToWorld(cx, cy){
  const [halfW, halfH] = visibleUnits();
  const minX = WORLD.minX + halfW, maxX = WORLD.maxX - halfW;
  const minY = WORLD.minY + halfH, maxY = WORLD.maxY - halfH;
  const worldW=WORLD.maxX-WORLD.minX, worldH=WORLD.maxY-WORLD.minY;
  const viewW=halfW*2, viewH=halfH*2;
  return [
    (viewW>=worldW)?(WORLD.minX+WORLD.maxX)/2:THREE.MathUtils.clamp(cx,minX,maxX),
    (viewH>=worldH)?(WORLD.minY+WORLD.maxY)/2:THREE.MathUtils.clamp(cy,minY,maxY)
  ];
}
const STIFF=60, DAMP=2*Math.sqrt(STIFF);
function followCamera(dt){
  const [halfW,halfH]=visibleUnits();
  const dzW=halfW*DZ_W, dzH=halfH*DZ_H;
  let shiftX=0, shiftY=0;
  if(player.position.x < camX - dzW) shiftX = player.position.x - (camX - dzW);
  if(player.position.x > camX + dzW) shiftX = player.position.x - (camX + dzW);
  if(player.position.y < camY - dzH) shiftY = player.position.y - (camY - dzH);
  if(player.position.y > camY + dzH) shiftY = player.position.y - (camY + dzH);
  let targetX=camX+shiftX, targetY=camY+shiftY;
  if(clampEnabled) [targetX,targetY]=clampToWorld(targetX,targetY);
  const ax = STIFF*(targetX - camX) - DAMP*camVX;
  const ay = STIFF*(targetY - camY) - DAMP*camVY;
  camVX+=ax*dt; camVY+=ay*dt; camX+=camVX*dt; camY+=camVY*dt;
}
function applyParallax(){
  const set=(g,f)=>{ g.position.x = camX*(1-f); g.position.y = camY*(1-f); };
  set(bg, bg.userData.parallax); set(mid, mid.userData.parallax); set(fg, fg.userData.parallax);
}
function updateRig(){
  if(usingOrtho){ camera=ortho; updateOrtho(); } else { camera=persp; updatePersp(); }
  applyParallax();
}

// ---------- Player Controller (from Step 2, plus sweep collision) ----------
const PLAYER_HEIGHT=1.1, PLAYER_HALF=PLAYER_HEIGHT*0.5, PLAYER_WIDTH=0.8;
const MOVE_SPEED=6.0, AIR_SPEED=5.0;
const GRAVITY=-18.0;
const JUMP_SPEED=8.5;
const JUMP_CUT_MULT=2.4;
const SNAP_DIST=0.45, MAX_SLOPE_DEG=38;
const COYOTE_TIME=0.12, JUMP_BUFFER=0.12;
const SNAP_LOCK_AFTER_JUMP=0.06;

const SKIN = 0.02;                      // small clearance at walls/ceilings
const RADIUS = PLAYER_WIDTH*0.5;        // "capsule" radius for sweep

const player = new THREE.Mesh(
  new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, 0.8),
  new THREE.MeshStandardMaterial({ color:0x88ff88, emissive:0x224422, emissiveIntensity:0.12 })
);
player.position.set(-12,-0.2,+0.05);    // slight +Z to sit in front of level
mid.add(player);

const raycaster = new THREE.Raycaster();
const UP = new THREE.Vector3(0,1,0);

let grounded=false, slopeDeg=0;
let groundNormal = new THREE.Vector3(0,1,0);

let vx=0, vy=0;
let coyoteTimer=0, jumpBufferTimer=0, snapLock=0;
let jumpHeld=false;

const colliders=[]; level.traverse(o=>{ if(o.isMesh){ colliders.push(o); } });

// Debug viz
const rayViz = new THREE.Group(); mid.add(rayViz);
const rayDown = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,-1,0)]), new THREE.LineBasicMaterial({ color:0x66ccff }));
const rayNormal = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,1,0)]), new THREE.LineBasicMaterial({ color:0xffaa00 }));
const sweepViz = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(1,0,0)]), new THREE.LineBasicMaterial({ color:0xff66ff }));
rayViz.add(rayDown, rayNormal, sweepViz);
let showRay=true, showSweep=false;

// Input
const input={left:false,right:false};
addEventListener('keydown', e=>{
  const k=e.key.toLowerCase();
  if(k==='a'||k==='arrowleft')  input.left=true;
  if(k==='d'||k==='arrowright') input.right=true;
  if(k==='w'||k==='arrowup'||k===' ') { jumpHeld=true; jumpBufferTimer=JUMP_BUFFER; }
  if(k==='g'){ showRay=!showRay; rayDown.visible=rayNormal.visible=showRay; }
  if(k==='c'){ showSweep=!showSweep; sweepViz.visible=showSweep; }
  if(k==='h'){ groundWireframe=!groundWireframe; setWireframe(groundWireframe); }
  if(k==='r'){ player.position.set(-12,-0.2,+0.05); vx=vy=0; coyoteTimer=jumpBufferTimer=snapLock=0; }
  if(k==='p'){ usingOrtho=!usingOrtho; updateRig(); }
  if(k==='m') clampEnabled=!clampEnabled;
  if(k==='1'){ bg.userData.parallax=0.40; mid.userData.parallax=1.00; fg.userData.parallax=1.20; }
  if(k==='2'){ bg.userData.parallax=0.25; mid.userData.parallax=1.00; fg.userData.parallax=1.50; }
  if(k==='3'){ bg.userData.parallax=0.10; mid.userData.parallax=1.00; fg.userData.parallax=1.60; }
  if(k==='4'){ bg.userData.parallax=0.05; mid.userData.parallax=1.00; fg.userData.parallax=1.80; }
  if(k==='k') setPPU(PIXELS_PER_UNIT-4);
  if(k==='l') setPPU(PIXELS_PER_UNIT+4);
  if(k==='b'){ bounds.visible=!bounds.visible; }
});
addEventListener('keyup', e=>{
  const k=e.key.toLowerCase();
  if(k==='a'||k==='arrowleft')  input.left=false;
  if(k==='d'||k==='arrowright') input.right=false;
  if(k==='w'||k==='arrowup'||k===' ') { jumpHeld=false; }
});
function setPPU(ppu){ PIXELS_PER_UNIT=THREE.MathUtils.clamp(ppu,MIN_PPU,MAX_PPU); }

// Bounds overlay
const bounds = new THREE.LineSegments((()=>{
  const g=new THREE.BufferGeometry();
  const p=new Float32Array([
    WORLD.minX,WORLD.minY,0, WORLD.maxX,WORLD.minY,0,
    WORLD.maxX,WORLD.minY,0, WORLD.maxX,WORLD.maxY,0,
    WORLD.maxX,WORLD.maxY,0, WORLD.minX,WORLD.maxY,0,
    WORLD.minX,WORLD.maxY,0, WORLD.minX,WORLD.minY,0
  ]);
  g.setAttribute('position', new THREE.BufferAttribute(p,3));
  return g;
})(), new THREE.LineBasicMaterial({ color:0x00ff99 }));
bounds.position.z = 0.01; bounds.visible=false; mid.add(bounds);

// ----- Downward snap (same as Step 2) -----
function snapToGround(){
  if(snapLock>0) { grounded=false; return; } // ignore while just jumped

  grounded=false; slopeDeg=0;

  const origin = new THREE.Vector3(player.position.x, player.position.y - PLAYER_HALF + 0.05, player.position.z);
  const dir = new THREE.Vector3(0,-1,0);
  raycaster.set(origin, dir); raycaster.far = SNAP_DIST + 0.1;

  const hits = raycaster.intersectObjects(colliders, false);
  if(hits.length===0){
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
    return;
  }

  const hit = hits[0];
  const n = hit.face?.normal ? hit.face.normal.clone().applyNormalMatrix(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)) : new THREE.Vector3(0,1,0);
  n.normalize();
  groundNormal.copy(n);

  slopeDeg = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(n.dot(UP), -1, 1)));
  const dy = origin.y - hit.point.y;

  if(dy >= -0.02 && dy <= SNAP_DIST && slopeDeg <= MAX_SLOPE_DEG){
    player.position.y = hit.point.y + PLAYER_HALF;
    vy = 0; grounded = true;
    // viz
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
    rayNormal.geometry.setFromPoints([hit.point, hit.point.clone().addScaledVector(n, 1.0)]);
  } else {
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
  }
}

// ----- NEW: Sweep collision (walls/ceilings) -----
// Returns corrected step vector (Vector2) and sets vy=0 on ceiling bonk.
const tmpV = new THREE.Vector3(), tmpN = new THREE.Vector3();
// Treat only walls/ceilings in sweep; ground is handled by snapToGround().
function sweepCollide(prevX, prevY, stepX, stepY){
  const dist = Math.hypot(stepX, stepY);
  if(dist <= 1e-6) return { dx:0, dy:0, hit:false };

  const dir = new THREE.Vector3(stepX/dist, stepY/dist, 0);
  const yFeet = prevY - PLAYER_HALF + 0.05;
  const yMid  = prevY;
  const yHead = prevY + PLAYER_HALF - 0.05;
  const origins = [
    new THREE.Vector3(prevX, yFeet, player.position.z),
    new THREE.Vector3(prevX, yMid,  player.position.z),
    new THREE.Vector3(prevX, yHead, player.position.z),
  ];

  const far = dist + RADIUS + SKIN;
  raycaster.far = far;

  let minHit = Infinity, best = null;
  const normalMat = new THREE.Matrix3();

  for(const o of origins){
    raycaster.set(o, dir);
    const hits = raycaster.intersectObjects(colliders, false);
    if(!hits.length) continue;

    for(const h of hits){
      if(!h.face) continue;
      normalMat.getNormalMatrix(h.object.matrixWorld);
      const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();

      // ✅ Ignore ground while falling; snapToGround() will catch it.
      if(stepY < 0 && n.y > 0.45) continue;

      // Consider only faces opposing our motion.
      if(n.dot(dir) < -0.2 && h.distance < minHit){
        minHit = h.distance;
        best = { normal: n, point: h.point.clone() };
      }
      break; // nearest-first
    }
  }

  if(!best){
    if(showSweep){
      const a = new THREE.Vector3(prevX, prevY, player.position.z);
      sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, dist)]);
    }
    return { dx:stepX, dy:stepY, hit:false };
  }

  // Walls/ceilings: stop just shy of contact (capsule radius + skin).
  const allowed = Math.max(0, minHit - (RADIUS + SKIN));
  const dx = dir.x * allowed;
  const dy = dir.y * allowed;

  // Ceiling bonk cuts upward velocity.
  if(stepY > 0 && best.normal.y < -0.3) vy = 0;

  if(showSweep){
    const a = new THREE.Vector3(prevX, prevY, player.position.z);
    sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, allowed)]);
  }
  return { dx, dy, hit:true };
}


// ---------- Resize ----------
addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateDZ(); updateRig();
});

// ---------- Main loop ----------
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  if(coyoteTimer>0) coyoteTimer -= dt;
  if(jumpBufferTimer>0) jumpBufferTimer -= dt;
  if(snapLock>0) snapLock -= dt;

  const ix = (input.right?1:0) - (input.left?1:0);

  // buffered jump if grounded/coyote
  if(jumpBufferTimer>0 && (grounded || coyoteTimer>0)){
    vy = JUMP_SPEED;
    const carry = ix * MOVE_SPEED; // carry ground speed on takeoff
    vx = carry;
    grounded = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
    snapLock = SNAP_LOCK_AFTER_JUMP;
  }

  // extra gravity for short hops
  const extraG = (!jumpHeld && vy > 0) ? (JUMP_CUT_MULT * GRAVITY) : 0;

  // Compute intended step BEFORE applying it (so we can sweep)
  let stepX = 0, stepY = 0;

  if(grounded){
    coyoteTimer = COYOTE_TIME;
    if(ix !== 0){
      // slope-aligned tangent move
      const t = new THREE.Vector3(groundNormal.y, -groundNormal.x, 0).normalize();
      if (t.x * ix < 0) t.multiplyScalar(-1);
      const speed = MOVE_SPEED * Math.abs(ix);
      stepX += t.x * speed * dt;
      stepY += t.y * speed * dt;
    }
  }else{
    // airborne control + gravity
    vx = ix * AIR_SPEED;
    stepX += vx * dt;
    vy += (GRAVITY + extraG) * dt;
    stepY += vy * dt;
  }

  const prevX = player.position.x;
  const prevY = player.position.y;

  // Sweep collision against level meshes
  const { dx, dy } = sweepCollide(prevX, prevY, stepX, stepY);
  player.position.x = prevX + dx;
  player.position.y = prevY + dy;

  // Downward snap (ground detection/settle)
  const wasGrounded = grounded;
  snapToGround();
  if(!grounded && wasGrounded && coyoteTimer<=0){
    coyoteTimer = COYOTE_TIME;
  }

  // Follow & render
  followCamera(dt);
  updateRig();

  hud.textContent =
    `L11 · Step 3 — grounded=${grounded} · vy=${vy.toFixed(2)} · slope=${grounded ? slopeDeg.toFixed(1)+'°' : '—'} · coyote=${Math.max(0,coyoteTimer).toFixed(2)} · buffer=${Math.max(0,jumpBufferTimer).toFixed(2)}`;
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
