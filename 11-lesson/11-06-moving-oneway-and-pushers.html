<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 11 · Step 6 — Moving One-Way + Pushers + Two Vertical Behaviors</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#131722}
  #app{width:100%;height:100%}
  .hud{position:fixed;top:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.55);color:#fff;font:13px/1.35 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,.45);color:#fff;font:12px/1.35 monospace}
  #dz{position:fixed;left:0;top:0;pointer-events:none;border:2px solid rgba(255,255,255,.85)}
</style>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="hud" class="hud">
  L11 · Step 6 — grounded=false · vy=0.00 · carry=0.00,0.00 · slope=— · coyote=0.00 · buffer=0.00 · drop=0.00 · clamp=on
</div>
<div id="dz"></div>
<div class="help">
  Move: <b>A/D</b> · Jump: <b>Space/W/↑</b> · <b>Down+Jump</b> drops through <u>one-way</u> only · Rays: <b>G</b> · Sweep: <b>C</b> · Wireframe: <b>H</b> · Reset: <b>R</b><br/>
  Parallax: <b>1/2/3/4</b> · <b>M</b> clamp on/off · Bounds: <b>B</b> · Ortho/Persp: <b>P</b> · PPU: <b>K</b>/<b>L</b>
</div>

<script type="module">
const THREE = await import('three');

const app  = document.getElementById('app');
const hud  = document.getElementById('hud');
const dzEl = document.getElementById('dz');

// ---------------- Renderer ----------------
const renderer = new THREE.WebGLRenderer({ antialias:true });
app.appendChild(renderer.domElement);
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x131722);
if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

// ---------------- Scene & Layers ----------------
const scene = new THREE.Scene();
const bg  = new THREE.Group();  bg.userData.parallax  = 0.25;
const mid = new THREE.Group();  mid.userData.parallax = 1.00;
const fg  = new THREE.Group();  fg.userData.parallax  = 1.50;
bg.position.z=-10; mid.position.z=0; fg.position.z=10;
scene.add(bg, mid, fg);

// Sky gradient
const skyMat = new THREE.ShaderMaterial({
  uniforms:{ top:{value:new THREE.Color(0x334a7a)}, bottom:{value:new THREE.Color(0x1a2336)} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`uniform vec3 top; uniform vec3 bottom; varying vec2 vUv;
    void main(){ vec3 c = mix(bottom, top, clamp(vUv.y,0.0,1.0)); gl_FragColor=vec4(c,1.0); }`
});
skyMat.depthWrite=false; skyMat.depthTest=false;
const sky = new THREE.Mesh(new THREE.PlaneGeometry(1,1), skyMat);
sky.renderOrder = -100; bg.add(sky);

// ---------------- Level geometry ----------------
const LEVEL_Z = -0.05;
const THICK   = 0.30;
const groundMat = new THREE.MeshStandardMaterial({ color:0x2e3758, roughness:0.9 });
const rampMat   = new THREE.MeshStandardMaterial({ color:0x3a5b8f, roughness:0.85 });
const oneWayMat = new THREE.MeshStandardMaterial({ color:0x7d5cff, roughness:0.6, emissive:0x171133, emissiveIntensity:0.25 });
const moverMat  = new THREE.MeshStandardMaterial({ color:0xffa200, roughness:0.55, metalness:0.0, emissive:0x331a00, emissiveIntensity:0.25 });

let groundWireframe=false;
function setWireframe(on){ groundMat.wireframe=on; rampMat.wireframe=on; oneWayMat.wireframe=on; moverMat.wireframe=on; }

const level = new THREE.Group(); level.position.z = LEVEL_Z; mid.add(level);

function flat(w, y=-1, x=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(w,0.5,THICK), groundMat);
  m.position.set(x,y-0.25,0); m.receiveShadow=true; return m;
}
function ramp(w, h, x=0, y=-1, up=true){
  const s = new THREE.Shape();
  if (up){ s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(w/2,h); }
  else   { s.moveTo(-w/2,0); s.lineTo(w/2,0); s.lineTo(-w/2,h); }
  s.closePath();
  const geo = new THREE.ExtrudeGeometry(s, { depth: THICK, bevelEnabled:false });
  geo.translate(0,0,-THICK/2);
  const m = new THREE.Mesh(geo, rampMat);
  m.position.set(x,y,0); m.receiveShadow=true; return m;
}
function oneWay(w=4, x=0, y=1.2){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.18, THICK*0.7), oneWayMat);
  m.position.set(x, y, 0);
  m.userData.oneWay = true;
  return m;
}

// --- Movers ---
function movingPlatform({from=[0,0], to=[4,0], w=3.5, h=0.35, speed=2.0, oneWay=false, handoff=false, tag='' }){
  const mat = oneWay ? oneWayMat : moverMat;
  const geo = new THREE.BoxGeometry(w, h, THICK);
  const m   = new THREE.Mesh(geo, mat);
  m.userData.size  = { w, h };
  m.userData.oneWay = !!oneWay;
  m.userData.handoff = !!handoff; // “handoff to static while descending”
  m.userData.tag = tag;
  m.userData.mover = {
    from: new THREE.Vector2(from[0], from[1]),
    to:   new THREE.Vector2(to[0],   to[1]),
    u: 0, dir: 1, speed,
    len: new THREE.Vector2(to[0]-from[0], to[1]-from[1]).length(),
    h,
    last: new THREE.Vector2(), delta: new THREE.Vector2()
  };
  m.position.set(from[0], from[1]-h*0.5, 0); // mesh centered from top line
  m.userData.mover.last.set(m.position.x, m.position.y);
  level.add(m);
  return m;
}

// Course (static)
level.add(flat(12,-1, -12));
level.add(ramp(8,3, -1,-1, true));
level.add(flat(10, 0.5, 8));
level.add(ramp(6,-2, 14,0.5, false));
level.add(flat(12,-1, 23));
level.add(oneWay(4, 5.5, 1.1));
level.add(oneWay(5, 18.0, 2.3));

// Movers
const movers = [];
// Horizontal moving one-way (jump-through both ways + drop-through)
const hA = movingPlatform({ from:[-4, 1.4], to:[ 2, 1.4], w:3.5, h:0.18, speed:2.0, oneWay:true,  handoff:false, tag:'H-A' });
movers.push(hA);
// Vertical A — jump-through elevator, hands off to static on the way down
const vA = movingPlatform({ from:[16, 3.2], to:[16, 0.8], w:3.2, h:0.18, speed:1.6, oneWay:true,  handoff:true,  tag:'V-A' });
movers.push(vA);
// Vertical B — solid elevator, no-through, vertical-only push, desc handoff to static
const vB = movingPlatform({ from:[6,  3.4], to:[6,  0.9], w:3.2, h:0.35, speed:1.4, oneWay:false, handoff:false, tag:'V-B' });
movers.push(vB);

// ---------------- Lights ----------------
scene.add(new THREE.HemisphereLight(0x9fb8ff, 0x1b2030, 0.65));
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const dir = new THREE.DirectionalLight(0xffffff,1.25); dir.position.set(6,10,6); scene.add(dir);

// ---------------- Camera rig ----------------
let PIXELS_PER_UNIT=64; const MIN_PPU=16, MAX_PPU=256;
const aspect = ()=> window.innerWidth / window.innerHeight;

const ortho = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
ortho.position.set(0,0,10); ortho.lookAt(0,0,0);

const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
let perspDist=10; persp.position.set(0,0,perspDist); persp.lookAt(0,0,0);

let usingOrtho=true; let camera=ortho;
let camX=0, camY=0, camVX=0, camVY=0;

const WORLD = { minX:-14, maxX:26, minY:-4, maxY:8 };
let clampEnabled = true;

function visibleUnitsOrtho(){ const halfH=(window.innerHeight/PIXELS_PER_UNIT)*0.5; return [halfH*aspect(), halfH]; }
function visibleUnitsPersp(){ const halfH=Math.tan((Math.PI/180)*(persp.fov*0.5))*perspDist; return [halfH*aspect(), halfH]; }
function visibleUnits(){ return usingOrtho?visibleUnitsOrtho():visibleUnitsPersp(); }
function sizeSky(){ const [halfW,halfH]=visibleUnits(); sky.scale.set(halfW*4,halfH*2,1); }

function updateOrtho(){
  const [halfW,halfH]=visibleUnitsOrtho();
  ortho.left=-halfW+camX; ortho.right=halfW+camX; ortho.top=halfH+camY; ortho.bottom=-halfH+camY;
  ortho.updateProjectionMatrix();
  ortho.position.set(camX,camY,10); ortho.lookAt(camX,camY,0);
  sizeSky();
}
function updatePersp(){
  persp.aspect=aspect(); persp.updateProjectionMatrix();
  persp.position.set(camX,camY,perspDist); persp.lookAt(camX,camY,0);
  sizeSky();
}
function clampToWorld(cx, cy){
  const [halfW, halfH] = visibleUnits();
  const minX = WORLD.minX + halfW, maxX = WORLD.maxX - halfW;
  const minY = WORLD.minY + halfH, maxY = WORLD.maxY - halfH;
  const worldW=WORLD.maxX-WORLD.minX, worldH=WORLD.maxY-WORLD.minY;
  const viewW=halfW*2, viewH=halfH*2;
  return [
    (viewW>=worldW)?(WORLD.minX+WORLD.maxX)/2:THREE.MathUtils.clamp(cx,minX,maxX),
    (viewH>=worldH)?(WORLD.minY+WORLD.maxY)/2:THREE.MathUtils.clamp(cy,minY,maxY)
  ];
}

// Dead-zone + HUD
let DZ_W=0.40, DZ_H=0.30; const EPS = 1e-3;
function dzBounds(moveX=0, moveY=0){
  const [halfW, halfH] = visibleUnits();
  const viewL = camX - halfW, viewR = camX + halfW;
  const viewB = camY - halfH, viewT = camY + halfH;
  if(!clampEnabled){
    const dzHalfW = halfW * DZ_W, dzHalfH = halfH * DZ_H;
    return { left:camX-dzHalfW, right:camX+dzHalfW, bottom:camY-dzHalfH, top:camY+dzHalfH, halfW, halfH, viewL, viewB };
  }
  const atL = Math.abs(camX - (WORLD.minX + halfW)) <= EPS;
  const atR = Math.abs(camX - (WORLD.maxX - halfW)) <= EPS;
  const atB = Math.abs(camY - (WORLD.minY + halfH)) <= EPS;
  const atT = Math.abs(camY - (WORLD.maxY - halfH)) <= EPS;
  const dzHalfW = halfW * DZ_W, dzHalfH = halfH * DZ_H;
  let left = camX - dzHalfW, right = camX + dzHalfW, bottom = camY - dzHalfH, top = camY + dzHalfH;
  if (atL && moveX < -0.001) { left=viewL; right=Math.min(viewL+2*dzHalfW, viewR); }
  if (atR && moveX >  0.001) { right=viewR; left=Math.max(viewR-2*dzHalfW, viewL); }
  if (atB && moveY < -0.001) { bottom=viewB; top=Math.min(viewB+2*dzHalfH, viewT); }
  if (atT && moveY >  0.001) { top=viewT; bottom=Math.max(viewT-2*dzHalfH, viewB); }
  return { left, right, bottom, top, halfW, halfH, viewL, viewB };
}
function updateDZHud(dz){
  const pxW = ((dz.right  - dz.left)   / (2*dz.halfW)) * innerWidth;
  const pxH = ((dz.top    - dz.bottom) / (2*dz.halfH)) * innerHeight;
  const pxX = ((dz.left   - dz.viewL)  / (2*dz.halfW)) * innerWidth;
  const pxY = ((dz.bottom - dz.viewB)  / (2*dz.halfH)) * innerHeight;
  dzEl.style.width  = Math.round(pxW) + 'px';
  dzEl.style.height = Math.round(pxH) + 'px';
  dzEl.style.left   = Math.round(pxX) + 'px';
  dzEl.style.top    = Math.round(pxY) + 'px';
}
function followCamera(dt){
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;
  const dz = dzBounds(moveX, moveY);
  let shiftX=0, shiftY=0;
  if (player.position.x < dz.left)   shiftX = player.position.x - dz.left;
  if (player.position.x > dz.right)  shiftX = player.position.x - dz.right;
  if (player.position.y < dz.bottom) shiftY = player.position.y - dz.bottom;
  if (player.position.y > dz.top)    shiftY = player.position.y - dz.top;
  let targetX = camX + shiftX, targetY = camY + shiftY;
  if (clampEnabled) [targetX, targetY] = clampToWorld(targetX, targetY);
  const ax = STIFF * (targetX - camX) - DAMP * camVX;
  const ay = STIFF * (targetY - camY) - DAMP * camVY;
  camVX += ax * dt;  camVY += ay * dt;
  camX  += camVX * dt; camY  += camVY * dt;
}
function applyParallax(){
  const set=(g,f)=>{ g.position.x = camX*(1-f); g.position.y = camY*(1-f); };
  set(bg, bg.userData.parallax); set(mid, mid.userData.parallax); set(fg, fg.userData.parallax);
}
function updateRig(){
  if(usingOrtho){ camera=ortho; updateOrtho(); } else { camera=persp; updatePersp(); }
  applyParallax();
}

// ---------------- Player controller ----------------
const PLAYER_HEIGHT=1.1, PLAYER_HALF=PLAYER_HEIGHT*0.5, PLAYER_WIDTH=0.8;
const MOVE_SPEED=6.0, AIR_SPEED=5.0;
const GRAVITY=-18.0;
const JUMP_SPEED=8.5;
const JUMP_CUT_MULT=2.4;
const SNAP_DIST=0.35, MAX_SLOPE_DEG=38;
const COYOTE_TIME=0.12, JUMP_BUFFER=0.12;
const SNAP_LOCK_AFTER_JUMP=0.06;
const SKIN=0.02, RADIUS=PLAYER_WIDTH*0.5;

// Drop-through gating (from your working patch)
const DOWN_BUFFER = 0.20, DROP_ARM_TIME = 0.25;
let downBuffer = 0, dropArmed = 0;
const DROP_TIME=0.25, DROP_LOCK=0.08;
let dropIgnoreObj=null, dropTimer=0;

// Auto-jump
let autoJumpCooldown = 0;     // global pogo rate limiter
let vbIgnoreTimer = 0;        // short ignore window after forcing drop off V-B

const player = new THREE.Mesh(
  new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, 0.8),
  new THREE.MeshStandardMaterial({ color:0x88ff88, emissive:0x224422, emissiveIntensity:0.12 })
);
player.position.set(-12,-0.2,+0.05); mid.add(player);

let lastPlayerX = player.position.x, lastPlayerY = player.position.y;

const raycaster = new THREE.Raycaster();
const UP = new THREE.Vector3(0,1,0);
let grounded=false, slopeDeg=0, groundNormal=new THREE.Vector3(0,1,0), lastGround=null;
let vx=0, vy=0, coyoteTimer=0, jumpBufferTimer=0, snapLock=0;
let jumpHeld=false, downHeld=false;

// Colliders
const colliders=[]; level.traverse(o=>{ if(o.isMesh) colliders.push(o); });

// Debug viz
const rayViz = new THREE.Group(); mid.add(rayViz);
const rayDown = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,-1,0)]), new THREE.LineBasicMaterial({ color:0x66ccff }));
const rayNormal = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,1,0)]), new THREE.LineBasicMaterial({ color:0xffaa00 }));
const sweepViz = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(1,0,0)]), new THREE.LineBasicMaterial({ color:0xff66ff }));
rayViz.add(rayDown, rayNormal, sweepViz);
let showRay=true, showSweep=false;

// Input (we allow auto-repeat for Jump to feel snappy, but auto-jump is explicit anyway)
const input = { left:false, right:false };
addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();

  if (k==='a'||k==='arrowleft')  input.left=true;
  if (k==='d'||k==='arrowright') input.right=true;

  if (k==='s'||k==='arrowdown'){ downHeld=true; downBuffer=DOWN_BUFFER; }

  if (k==='w'||k==='arrowup'||k===' '){
    const downNow = (downHeld || downBuffer > 0);

    // If grounded on a one-way, Down+Jump => drop immediately
    if (downNow && grounded && lastGround && lastGround.userData.oneWay){
      requestDropThrough();
      jumpBufferTimer = 0; dropArmed = 0; return;
    }
    // normal jump press (buffered)
    jumpHeld=true; jumpBufferTimer=JUMP_BUFFER;
    if (downNow) dropArmed = DROP_ARM_TIME;
  }

  if(k==='g'){ showRay=!showRay; rayDown.visible=rayNormal.visible=showRay; }
  if(k==='c'){ showSweep=!showSweep; sweepViz.visible=showSweep; }
  if(k==='h'){ groundWireframe=!groundWireframe; setWireframe(groundWireframe); }
  if(k==='r'){ player.position.set(-12,-0.2,+0.05); vx=vy=0; coyoteTimer=jumpBufferTimer=snapLock=dropTimer=vbIgnoreTimer=0; lastGround=null; }
  if(k==='p'){ usingOrtho=!usingOrtho; updateRig(); }
  if(k==='m'){ clampEnabled=!clampEnabled; }
  if(k==='1'){ bg.userData.parallax=0.40; mid.userData.parallax=1.00; fg.userData.parallax=1.20; }
  if(k==='2'){ bg.userData.parallax=0.25; mid.userData.parallax=1.00; fg.userData.parallax=1.50; }
  if(k==='3'){ bg.userData.parallax=0.10; mid.userData.parallax=1.00; fg.userData.parallax=1.60; }
  if(k==='4'){ bg.userData.parallax=0.05; mid.userData.parallax=1.00; fg.userData.parallax=1.80; }
  if(k==='k') setPPU(PIXELS_PER_UNIT-4);
  if(k==='l') setPPU(PIXELS_PER_UNIT+4);
  if(k==='b'){ bounds.visible=!bounds.visible; }
});
addEventListener('keyup', e=>{
  const k=e.key.toLowerCase();
  if (k==='a'||k==='arrowleft')  input.left=false;
  if (k==='d'||k==='arrowright') input.right=false;
  if (k==='s'||k==='arrowdown')  downHeld=false;
  if (k==='w'||k==='arrowup'||k===' ') { jumpHeld=false; }
});
function setPPU(ppu){ PIXELS_PER_UNIT=THREE.MathUtils.clamp(ppu,MIN_PPU,MAX_PPU); }

// World bounds overlay
const bounds = new THREE.LineSegments((()=>{
  const g=new THREE.BufferGeometry();
  const p=new Float32Array([
    WORLD.minX,WORLD.minY,0, WORLD.maxX,WORLD.minY,0,
    WORLD.maxX,WORLD.minY,0, WORLD.maxX,WORLD.maxY,0,
    WORLD.maxX,WORLD.maxY,0, WORLD.minX,WORLD.maxY,0,
    WORLD.minX,WORLD.maxY,0, WORLD.minX,WORLD.minY,0
  ]);
  g.setAttribute('position', new THREE.BufferAttribute(p,3));
  return g;
})(), new THREE.LineBasicMaterial({ color:0x00ff99 }));
bounds.position.z = 0.01; bounds.visible=false; mid.add(bounds);

// -------- Ground snap (handles one-way correctly) --------
const normalMat = new THREE.Matrix3();
function snapToGround(prevFeetY, wasGroundedPrev=false, ix=0){
  if(snapLock>0) { grounded=false; return; }
  grounded=false; slopeDeg=0;

  const origin = new THREE.Vector3(player.position.x, player.position.y - PLAYER_HALF + 0.05, player.position.z);
  const dir = new THREE.Vector3(0,-1,0);
  raycaster.set(origin, dir); raycaster.far = SNAP_DIST + 0.2;

  const hits = raycaster.intersectObjects(colliders, false);
  if(!hits.length){
    rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
    return;
  }

  for(const h of hits){
    if(!h.face) continue;
    if (vbIgnoreTimer>0 && h.object===vB) continue; // short ignore after forced drop

    // inside the hits loop, *before* using this hit:
    if (lastGround === vB && h.object !== vB) {
      if (isOnTopOf(vB)) {
        continue;     // keep riding V-B; no auto transfer
      }
      // not on top anymore => allow normal landing on this hit
    }

    const isOneWay = !!h.object.userData.oneWay;

    normalMat.getNormalMatrix(h.object.matrixWorld);
    const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();
    if(n.y <= 0.45) continue; // ground-ish

    const topY = h.point.y;
    const dy = origin.y - h.point.y;

    if (isOneWay){
      const mover      = h.object.userData.mover || null;     // present for V-A
      const isVA       = (h.object === vA);
      const topY       = h.point.y;                           // contact Y on the top face
      const feetYNow   = player.position.y - PLAYER_HALF;
      const rising     = mover && mover.delta.y >  0;
      const descending = mover && mover.delta.y <  0;

      const wasOnSolid = wasGroundedPrev && lastGround
                      && !lastGround.userData.oneWay
                      && !lastGround.userData.mover;          // true for static ground/ramps

      if (isVA){
        // ─── RISING rules ─────────────────────────────────────────────
        if (rising){
          // If V-A is already above feet → ignore (no side yoink)
          if (topY > feetYNow + 0.02) { continue; }
          // else (top at/below feet): allow pickup; "first surface wins"
          // fall through to accept tests below
        }

        // ─── DESCENDING rules ─────────────────────────────────────────
        if (descending) {
          const feetYNow = player.position.y - PLAYER_HALF;
          // Must be at/below feet to be eligible
          if (topY > feetYNow + 0.02) { 
            continue; // above feet: ignore
          }

          // ✅ Only pick if the player is in the air (not standing on any platform)
          const playerInAir = !wasGroundedPrev;
          if (!playerInAir) {
            continue; // on a platform: do NOT pick on the way down
          }

          // else: allowed to pick (in air); fall through to normal one-way acceptance
        }
      } else {
        // Non-moving one-way (static purple ledges) – keep your default behavior.
      }

      // Default one-way accept tests (apply for both static one-ways and V-A after gating):
      if (vy > 0) continue;                    // rising player: pass through
      if (prevFeetY < topY - 0.01) continue;   // coming from below: pass through
      if (dropTimer > 0 && dropIgnoreObj === h.object) continue;

      // If we get here, we can land on this one-way.
    }


    const angle = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(n.dot(UP),-1,1)));
    if(dy >= -0.02 && dy <= SNAP_DIST && angle <= MAX_SLOPE_DEG){
      player.position.y = topY + PLAYER_HALF;
      vy = 0; grounded=true; groundNormal.copy(n); lastGround=h.object;

      rayDown.geometry.setFromPoints([origin, origin.clone().addScaledVector(dir, raycaster.far)]);
      rayNormal.geometry.setFromPoints([h.point, h.point.clone().addScaledVector(n, 1.0)]);
      break;
    }
  }
}

// -------- Sweep collision (walls/ceilings; ignore one-way, ignore VB during ignore window) --------
function sweepCollide(prevX, prevY, stepX, stepY){
  const dist = Math.hypot(stepX, stepY);
  if(dist <= 1e-6) return { dx:0, dy:0, hit:false };

  const dir = new THREE.Vector3(stepX/dist, stepY/dist, 0);
  const yFeet = prevY - PLAYER_HALF + 0.05;
  const yMid  = prevY;
  const yHead = prevY + PLAYER_HALF - 0.05;
  const origins = [
    new THREE.Vector3(prevX, yFeet, player.position.z),
    new THREE.Vector3(prevX, yMid,  player.position.z),
    new THREE.Vector3(prevX, yHead, player.position.z),
  ];

  const far = dist + RADIUS + SKIN; raycaster.far = far;
  let minHit = Infinity, best=null;

  for(const o of origins){
    raycaster.set(o, dir);
    const hits = raycaster.intersectObjects(colliders, false);
    if(!hits.length) continue;

    for(const h of hits){
      if(!h.face) continue;
      if(h.object.userData.oneWay) continue; // skip one-way in sweep
      if(vbIgnoreTimer>0 && h.object===vB) continue; // skip VB during ignore

      normalMat.getNormalMatrix(h.object.matrixWorld);
      const n = h.face.normal.clone().applyNormalMatrix(normalMat).normalize();

      if(stepY < 0 && n.y > 0.45) continue;  // ignore ground while falling
      if(n.dot(dir) < -0.2 && h.distance < minHit){
        minHit = h.distance; best = { normal:n, point:h.point.clone() };
      }
      break;
    }
  }

  if(!best){
    if(showSweep){
      const a = new THREE.Vector3(prevX, prevY, player.position.z);
      sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, dist)]);
    }
    return { dx:stepX, dy:stepY, hit:false };
  }

  const allowed = Math.max(0, minHit - (RADIUS + SKIN));
  const dx = dir.x * allowed, dy = dir.y * allowed;
  if(stepY > 0 && best.normal.y < -0.3) vy = 0; // ceiling bonk
  if(showSweep){
    const a = new THREE.Vector3(prevX, prevY, player.position.z);
    sweepViz.geometry.setFromPoints([a, a.clone().addScaledVector(dir, allowed)]);
  }
  return { dx, dy, hit:true };
}

// Drop-through (working)
function requestDropThrough(){
  if (grounded && lastGround && lastGround.userData.oneWay) {
    dropIgnoreObj   = lastGround;
    dropTimer       = DROP_TIME;
    snapLock        = Math.max(snapLock, DROP_LOCK);
    grounded        = false;
    coyoteTimer     = 0;
    jumpBufferTimer = 0;
    vy              = Math.min(vy, -3.5);
    player.position.y -= 0.06;
  }
}

// === Movers: update + carry + V-B rules + handoffs ===
function updateMovers(dt){
  for(const m of movers){
    const d = m.userData.mover;
    if(d.len <= 0){ d.delta.set(0,0); continue; }
    d.last.set(m.position.x, m.position.y);
    d.u += d.dir * (d.speed * dt / d.len);
    if(d.u > 1){ d.u = 1 - (d.u - 1); d.dir = -1; }
    if(d.u < 0){ d.u = -d.u;          d.dir =  1; }
    const topX = THREE.MathUtils.lerp(d.from.x, d.to.x, d.u);
    const topY = THREE.MathUtils.lerp(d.from.y, d.to.y, d.u);
    m.position.set(topX, topY - d.h*0.5, 0);
    d.delta.set(m.position.x - d.last.x, m.position.y - d.last.y);
  }
}

function playerAABB(){ return { hx: PLAYER_WIDTH*0.5, hy: PLAYER_HALF, cx: player.position.x, cy: player.position.y }; }
function moverAABB(m){ const s = m.userData.size; return { hx: s.w*0.5, hy: s.h*0.5, cx: m.position.x, cy: m.position.y }; }
function isOnTopOf(m){
  if (!m) return false;
  const p = playerAABB();
  const a = moverAABB(m);
  // horizontal overlap?
  const penX = (a.hx + p.hx) - Math.abs(a.cx - p.cx);
  if (penX <= 0.02) return false;

  const topY  = a.cy + a.hy;
  const feetY = p.cy - p.hy;
  // feet sitting on (or within a hair of) m's top
  return (feetY >= topY - 0.06) && (feetY <= topY + 0.12);
}


// Solid V-B: vertical-only push (no side), NEVER auto-drop rider
function resolveVBVerticalOnly(){
  const p = playerAABB();
  const a = moverAABB(vB);
  const d = vB.userData.mover;
  const penX = (a.hx + p.hx) - Math.abs(a.cx - p.cx);
  const penY = (a.hy + p.hy) - Math.abs(a.cy - p.cy);
  if (penX <= 0 || penY <= 0) return; // no overlap

  // where are we relative to the platform?
  const topY = a.cy + a.hy, botY = a.cy - a.hy;
  const feetY = p.cy - p.hy, headY = p.cy + p.hy;
  const widthOverlapFrac = penX / (a.hx + p.hx);

  const onTop     = (feetY >= topY - 0.04) && (widthOverlapFrac > 0.25);
  const fromBelow = (headY <= botY + 0.04) && (widthOverlapFrac > 0.25);

  if (d.delta.y < 0) { // V-B descending
    if (onTop) {
      // ✅ If player is riding on top, keep riding — never auto-drop.
      player.position.y = topY + p.hy;
      grounded = true;
      lastGround = vB;
      if (vy > 0) vy = 0;
      return;
    }

    // ✅ Drop ONLY if V-B is actually above the player and coming down onto their head
    const hitFromAbove = fromBelow; // (headY <= botY + ε) and decent horizontal overlap
    if (hitFromAbove) {
      // push the player down out of overlap and give them a downward velocity
      player.position.y -= penY;
      grounded = false;
      vy = Math.min(vy, -JUMP_SPEED * 0.9);
      return;
    }

    // Side-ish or ambiguous overlap: clear vertically without “drop” behavior
    player.position.y -= penY;
    grounded = false;
    return;
  }


  if (d.delta.y > 0){ // V-B ascending
    if (fromBelow){
      // Push up vertically; snap/grounding will settle next frame if appropriate.
      player.position.y += penY;
      return;
    }
    // Side-ish overlap: still resolve vertically (up), never sideways for V-B.
    player.position.y += penY;
    return;
  }

  // If V-B happens to be stationary this frame, resolve along the dominant axis (vertical preference)
  if (penY >= penX){
    const sign = Math.sign(p.cy - a.cy) || 1;
    player.position.y += sign * penY;
  } else {
    // Even here, prefer **no sideways shove** on V-B: nudge vertically instead
    const sign = Math.sign(p.cy - a.cy) || 1;
    player.position.y += sign * penY;
  }
}


// Solids other than V-B: directional pushers with floor safety
function resolveOtherSolidMovers(){
  const p = playerAABB();
  for(const m of movers){
    if (m===vB || m.userData.oneWay) continue; // skip V-B here; skip one-ways
    const d = m.userData.mover, a = moverAABB(m);
    const penX = (a.hx + p.hx) - Math.abs(a.cx - p.cx);
    const penY = (a.hy + p.hy) - Math.abs(a.cy - p.cy);
    if (penX <= 0 || penY <= 0) continue;

    const domVertical = Math.abs(d.delta.y) >= Math.abs(d.delta.x);
    const topY = a.cy + a.hy, botY = a.cy - a.hy;
    const feetY = p.cy - p.hy, headY = p.cy + p.hy;
    const fracX = penX / (a.hx + p.hx);

    const pushSide = ()=>{
      const sign = Math.sign(p.cx - a.cx) || (d.delta.x >= 0 ? -1 : 1);
      player.position.x += sign * penX;
    };
    const pushVertical = (sign)=>{
      const target = player.position.y + sign*penY;
      // floor safety for “other” solids
      const minFeetY = WORLD.minY, minPlayerCy = minFeetY + p.hy + 1e-4;
      if (sign < 0 && target < minPlayerCy){ pushSide(); return; }
      player.position.y = target;
      if (sign < 0) grounded=false;
    };

    if (domVertical){
      if (d.delta.y < 0){
        const topContact = (feetY >= topY - 0.04) && (fracX > 0.25);
        topContact ? pushVertical(-1) : pushSide();
      } else if (d.delta.y > 0){
        const bottomContact = (headY <= botY + 0.04) && (fracX > 0.25);
        bottomContact ? pushVertical(+1) : pushSide();
      } else {
        (penX < penY) ? pushSide() : pushVertical(Math.sign(p.cy - a.cy) || 1);
      }
    } else {
      pushSide();
    }
  }
}

// Only movers with handoff=true place you on static ledge when descending
function handoffDescendingToStatic(m){
  if (!(grounded && lastGround===m && m.userData.handoff)) return;
  const d = m.userData.mover;
  if (d.delta.y >= -1e-6) return; // only when descending

  const origin = new THREE.Vector3(player.position.x, player.position.y - PLAYER_HALF + 0.05, player.position.z);
  const dir = new THREE.Vector3(0,-1,0);
  raycaster.set(origin, dir); raycaster.far = Math.max(SNAP_DIST, Math.abs(d.delta.y) + 0.35);
  const hits = raycaster.intersectObjects(colliders, false);
  for(const h of hits){
    if(!h.face || h.object === m) continue;
    if(h.object.userData.oneWay) continue; // ignore one-ways (e.g., V-A)
    const topY = h.point.y;
    if (topY <= origin.y + 0.05){
      player.position.y = topY + PLAYER_HALF;
      vy = 0; grounded = true; lastGround = h.object;
      return;
    }
  }
}

// ---------------- Resize ----------------
addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateRig();
  const dz = dzBounds(0,0);
  updateDZHud(dz);
});

// ---------------- Main loop ----------------
const STIFF=60, DAMP=2*Math.sqrt(STIFF);
let last=performance.now();
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000); last=now;
  if(coyoteTimer>0) coyoteTimer -= dt;
  if(jumpBufferTimer>0) jumpBufferTimer -= dt;
  if(snapLock>0) snapLock -= dt;
  if(dropTimer>0) dropTimer -= dt;
  if(autoJumpCooldown>0) autoJumpCooldown -= dt;
  if(vbIgnoreTimer>0) vbIgnoreTimer -= dt;

  const ix = (input.right?1:0) - (input.left?1:0);

  // Timers for input gating
  if (downBuffer > 0) downBuffer -= dt;
  if (dropArmed  > 0) dropArmed  -= dt;

  // 1) Move platforms first
  updateMovers(dt);

  // 2) Carry if standing on a mover (one-way or solid)
  let carryX=0, carryY=0;
  if (grounded && lastGround && lastGround.userData.mover){
    const d = lastGround.userData.mover;
    carryX = d.delta.x; carryY = d.delta.y;
    player.position.x += carryX;
    player.position.y += carryY;
  }

  // 3) Resolve collisions with movers
  resolveVBVerticalOnly();     // V-B: vertical-only, crush semantics
  resolveOtherSolidMovers();   // others: directional with floor safety

  // 4) If armed to drop and on a one-way, do it
  if (dropArmed > 0 && dropTimer <= 0 && grounded && lastGround && lastGround.userData.oneWay) {
    requestDropThrough(); dropArmed = 0;
  }

  // 5) Handoff to static while descending (V-A and V-B have handoff=true)
  handoffDescendingToStatic(vA);
  // handoffDescendingToStatic(vB); // V-B now hands off to static as requested

  // 6) Consume buffered jump (normal)
  if (jumpBufferTimer > 0
      && dropArmed <= 0
      && dropTimer <= 0
      && (grounded || coyoteTimer > 0)) {
    vy = JUMP_SPEED;
    grounded = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
    snapLock = SNAP_LOCK_AFTER_JUMP;
    autoJumpCooldown = 0.08;
  }

  // 7) Auto-jump: while holding Jump, ALWAYS pogo when grounded (any ground/platform), even with A/D
  if (jumpHeld && grounded && dropArmed<=0 && dropTimer<=0 && autoJumpCooldown<=0){
    vy = JUMP_SPEED;
    grounded = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
    snapLock = SNAP_LOCK_AFTER_JUMP;
    autoJumpCooldown = 0.08;
  }

  // 8) Physics integration
  const extraG = (!jumpHeld && vy > 0) ? (JUMP_CUT_MULT * GRAVITY) : 0;
  let stepX=0, stepY=0;
  if(grounded){
    coyoteTimer = COYOTE_TIME;
    if(ix !== 0){
      const t = new THREE.Vector3(groundNormal.y, -groundNormal.x, 0).normalize();
      if (t.x * ix < 0) t.multiplyScalar(-1);
      const speed = MOVE_SPEED * Math.abs(ix);
      stepX += t.x * speed * dt;
      stepY += t.y * speed * dt;
    }
  } else {
    vx = ix * AIR_SPEED;
    stepX += vx * dt;
    vy += (GRAVITY + extraG) * dt;
    stepY += vy * dt;
  }

  const prevX=player.position.x, prevY=player.position.y;
  const prevFeetY = prevY - PLAYER_HALF;

  // 9) Sweep against walls/ceilings
  const { dx, dy } = sweepCollide(prevX, prevY, stepX, stepY);
  player.position.x = prevX + dx;
  player.position.y = prevY + dy;

  // 10) Snap to ground (handles one-way; respects VB ignore window)
  const wasGrounded = grounded;
  snapToGround(prevFeetY, wasGrounded, ix);
  if(!grounded && wasGrounded && coyoteTimer<=0) coyoteTimer = COYOTE_TIME;

  // 11) Camera + HUD
  const moveX = player.position.x - lastPlayerX;
  const moveY = player.position.y - lastPlayerY;
  const dz = dzBounds(moveX, moveY);

  followCamera(dt);
  updateRig();
  updateDZHud(dz);

  hud.textContent =
    `L11 · Step 6 — grounded=${grounded} · vy=${vy.toFixed(2)} · carry=${carryX.toFixed(2)},${carryY.toFixed(2)} · ` +
    `slope=${grounded ? slopeDeg.toFixed(1)+'°' : '—'} · coyote=${Math.max(0,coyoteTimer).toFixed(2)} · buffer=${Math.max(0,jumpBufferTimer).toFixed(2)} · ` +
    `drop=${Math.max(0,dropTimer).toFixed(2)} · clamp=${clampEnabled?'on':'off'} · vbIgnore=${Math.max(0,vbIgnoreTimer).toFixed(2)}`;

  renderer.render(scene, camera);

  lastPlayerX = player.position.x;
  lastPlayerY = player.position.y;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
