<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Lesson 4 — Step 07 (Final Centered 2D↔3D Pairs)</title>
  <style>
    html,body{margin:0;height:100%;background:#0f1117;color:#e6e6e6;font-family:system-ui,Segoe UI,Roboto,sans-serif}
    canvas{display:block;width:100%;height:100%}
    #controls{position:absolute;top:10px;left:10px;display:flex;gap:10px;background:rgba(0,0,0,.5);padding:8px 10px;border-radius:8px;font-size:14px;align-items:center}
    #controls button,#controls label{cursor:pointer}
    #controls button{background:#1a1d2b;color:#e6e6e6;border:1px solid #444;border-radius:6px;padding:4px 10px}
    #controls button:hover{background:#2d3144}
    #hint{position:absolute;bottom:10px;left:10px;font-size:12px;color:#9aa4b2;background:rgba(0,0,0,.35);padding:6px 8px;border-radius:6px}
  </style>
</head>
<body>
  <div id="controls">
    <button id="btn-cam">Camera: PERSPECTIVE</button>
    <label><input id="cb-square" type="checkbox" checked> Square/Cube</label>
    <label><input id="cb-tri" type="checkbox" checked> Triangle/Pyramid</label>
    <button id="btn-rot">Rotate 3D: ON</button>
  </div>
  <canvas id="c"></canvas>
  <div id="hint">Step 07: Final — switch Ortho↔Perspective, toggle pairs, rotate 3D, centered framing</div>

  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

  // --- renderer ---
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setClearColor(0x0f1117, 1);

  // --- scene ---
  const scene = new THREE.Scene();

  // --- cameras (centered world) ---
  let cam = makePerspective();
  function makeOrtho(){
    const w = renderer.domElement.clientWidth, h = renderer.domElement.clientHeight;
    const ocam = new THREE.OrthographicCamera(-w/2, w/2, h/2, -h/2, 0.1, 5000);
    ocam.position.set(0,0,1000);
    ocam.lookAt(0,0,0);
    ocam.updateProjectionMatrix();
    return ocam;
  }
  function makePerspective(){
    const w = renderer.domElement.clientWidth, h = renderer.domElement.clientHeight;
    const pcam = new THREE.PerspectiveCamera(45, w/h, 0.1, 5000);
    pcam.position.set(0,0,800);
    pcam.lookAt(0,0,0);
    pcam.updateProjectionMatrix();
    return pcam;
  }

  // --- groups ---
  const group2D  = new THREE.Group();
  const group3D  = new THREE.Group();
  scene.add(group2D);
  scene.add(group3D);

  // --- shape/model helpers ---
  function addSquare(cx,cy,size,color){
    const g=new THREE.PlaneGeometry(size,size);
    const m=new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(g,m);
    mesh.position.set(cx,cy,0);
    return mesh;
  }
  function addTriangle(cx,cy,w,h,color){
    const s=new THREE.Shape();
    s.moveTo(0, -h/2);
    s.lineTo(-w/2, h/2);
    s.lineTo( w/2, h/2);
    s.closePath();
    const g=new THREE.ShapeGeometry(s);
    const m=new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(g,m);
    mesh.position.set(cx,cy,0);
    return mesh;
  }
  function addCube(cx,cy,size){
    const g=new THREE.BoxGeometry(size,size,size);
    const m=new THREE.MeshNormalMaterial();
    const mesh=new THREE.Mesh(g,m);
    mesh.position.set(cx,cy,0);
    return mesh;
  }
  function addPyramid(cx,cy,base,height){
    const g=new THREE.ConeGeometry(base/2, height, 4);
    const m=new THREE.MeshNormalMaterial();
    const mesh=new THREE.Mesh(g,m);
    mesh.position.set(cx,cy,0);
    mesh.rotation.y = Math.PI/4;
    return mesh;
  }

  // --- build pairs (same positions left/right) ---
  const square  = addSquare(-240,0,160,0xffffff);
  const triangle= addTriangle( 240,0,180,160,0x00ccff);
  group2D.add(square, triangle);

  const cube    = addCube( -240,0,160);
  const pyramid = addPyramid( 240,0,200,220);
  cube.position.z = -120;
  pyramid.position.z = 60;
  group3D.add(cube, pyramid);

  // --- UI elements ---
  const btnCam    = document.getElementById('btn-cam');
  const cbSquare  = document.getElementById('cb-square');
  const cbTri     = document.getElementById('cb-tri');
  const btnRot    = document.getElementById('btn-rot');
  let rotate3D = true;
  btnRot.addEventListener('click', ()=>{ rotate3D = !rotate3D; btnRot.textContent = `Rotate 3D: ${rotate3D?'ON':'OFF'}`; });

  // --- visibility control (single source of truth) ---
  function syncVisibility(){
    const persp = cam.isPerspectiveCamera === true;
    // whole-group swap: prevents 2D+3D appearing at once
    group2D.visible = !persp;
    group3D.visible =  persp;

    // per-pair checkboxes
    square.visible  = !persp && cbSquare.checked;
    triangle.visible= !persp && cbTri.checked;
    cube.visible    =  persp && cbSquare.checked;
    pyramid.visible =  persp && cbTri.checked;
  }

  // camera switch
  btnCam.addEventListener('click', ()=>{
    cam = cam.isPerspectiveCamera ? makeOrtho() : makePerspective();
    btnCam.textContent = `Camera: ${cam.isPerspectiveCamera ? 'PERSPECTIVE' : 'ORTHO'}`;
    syncVisibility(); // <-- important: apply after switching
  });

  // checkbox changes
  cbSquare.addEventListener('change', syncVisibility);
  cbTri.addEventListener('change', syncVisibility);

  // resize handling (also re-sync visibility)
  function resize(){
    const need = canvas.width!==Math.floor(canvas.clientWidth*devicePixelRatio) ||
                 canvas.height!==Math.floor(canvas.clientHeight*devicePixelRatio);
    if (need){
      renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
      cam = cam.isPerspectiveCamera ? makePerspective() : makeOrtho();
      syncVisibility(); // <-- important on resize too
    }
  }
  addEventListener('resize', resize);

  // initial visibility
  syncVisibility();

  // loop (rotate only when 3D is active)
  function tick(){
    resize();
    if (rotate3D && cam.isPerspectiveCamera){
      cube.rotation.x += 0.012;
      cube.rotation.y += 0.018;
      pyramid.rotation.y += 0.022;
    }
    renderer.render(scene, cam);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  </script>
</body>
</html>
