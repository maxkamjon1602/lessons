<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lesson 08 · Step 2/7 — FOV & Aspect</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0e0e12;}
    #app{width:100%;height:100%;}
    .overlay{position:fixed;top:8px;left:8px;padding:6px 10px;
      background:rgba(0,0,0,0.55);border-radius:8px;color:#fff;font:14px monospace;}
    .hud{position:fixed;top:8px;right:8px;padding:6px 10px;
      background:rgba(0,0,0,0.5);border-radius:8px;color:#fff;font:12px monospace;}
    .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;
      background:rgba(0,0,0,0.5);border-radius:8px;color:#fff;font:12px monospace;}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="overlay">Lesson 08 · Step 2/7 — FOV & Aspect</div>
  <div class="hud">
    FOV: <span id="fovVal">50</span>°<br>
    Aspect: <span id="aspVal">1.00</span>
  </div>
  <div class="help">Drag = orbit · Shift+Drag = pan · Wheel = dolly<br>
    Keys: [ = FOV– · ] = FOV+</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias:true});
    document.getElementById("app").appendChild(renderer.domElement);
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(DPR);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0e0e12);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    // Scene (consistent)
    const scene = new THREE.Scene();
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(20,20),
      new THREE.MeshStandardMaterial({color:0x232736, roughness:0.95})
    );
    ground.rotation.x = -Math.PI/2; ground.position.y = -1; scene.add(ground);
    const grid = new THREE.GridHelper(20,20,0x3a456f,0x2b3350);
    grid.position.y = -0.999; scene.add(grid);

    // Objects (consistent)
    const mat1 = new THREE.MeshStandardMaterial({color:0x88ccff, roughness:0.35, metalness:0.1});
    const mat2 = new THREE.MeshStandardMaterial({color:0xffc36e, roughness:0.55, metalness:0.2});
    const mat3 = new THREE.MeshPhysicalMaterial({color:0xD4AF37, metalness:1, roughness:0.2, clearcoat:0.3, clearcoatRoughness:0.15});
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.2,32,16), mat1); sphere.position.x=-3;
    const cube   = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), mat2);
    const pyr    = new THREE.Mesh(new THREE.ConeGeometry(1.1,1.8,5), mat3); pyr.position.x=3; pyr.position.y=-0.1;
    scene.add(sphere,cube,pyr);

    // Lights (consistent)
    scene.add(new THREE.AmbientLight(0xffffff,0.35));
    const dir = new THREE.DirectionalLight(0xffffff,1); dir.position.set(6,10,6); scene.add(dir);

    // Camera (Perspective only for this demo)
    let fov = 50; // degrees
    const camera = new THREE.PerspectiveCamera(fov, window.innerWidth/window.innerHeight, 0.1, 300);
    camera.position.set(5,3,8);

    // Orbit-lite controls (consistent)
    let theta=-0.4, phi=0.3, radius=9, panX=0, panY=0;
    let isDown=false, isPan=false, lastX=0, lastY=0;
    const cvs = renderer.domElement;

    cvs.addEventListener("pointerdown", e=>{
      isDown=true; isPan=e.shiftKey||(e.button===2);
      lastX=e.clientX; lastY=e.clientY;
    });
    cvs.addEventListener("pointerup", ()=>{isDown=false; isPan=false;});
    cvs.addEventListener("contextmenu", e=>e.preventDefault());
    cvs.addEventListener("pointermove", e=>{
      if(!isDown) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      if(isPan){ panX -= dx*0.01; panY += dy*0.01; }
      else { theta -= dx*0.005; phi = Math.max(-1.2, Math.min(1.2, phi - dy*0.005)); }
    });
    cvs.addEventListener("wheel", e=>{
      radius = Math.max(3, Math.min(40, radius + Math.sign(e.deltaY)*0.5));
    }, {passive:true});

    // HUD
    const fovVal = document.getElementById("fovVal");
    const aspVal = document.getElementById("aspVal");

    // FOV keys
    window.addEventListener("keydown", e=>{
      if(e.key === "["){ fov = Math.max(20, fov - 2); }
      if(e.key === "]"){ fov = Math.min(100, fov + 2); }
    });

    // Resize
    function onResize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      aspVal.textContent = (camera.aspect).toFixed(2);
    }
    window.addEventListener("resize", onResize);
    onResize(); // init HUD aspect

    // Animate
    const clock = new THREE.Clock();
    function frame(){
      const dt = clock.getDelta();
      // gentle motion
      cube.rotation.y += dt*0.5; sphere.rotation.y += dt*0.35; pyr.rotation.y -= dt*0.3;

      // apply FOV changes only when needed
      if (Math.abs(camera.fov - fov) > 0.001){
        camera.fov = fov;
        camera.updateProjectionMatrix();
        fovVal.textContent = fov.toFixed(0);
      }

      // orbit
      const cx=panX, cy=panY, cz=0;
      const x = cx + radius*Math.cos(phi)*Math.cos(theta);
      const y = cy + radius*Math.sin(phi);
      const z = cz + radius*Math.cos(phi)*Math.sin(theta);
      camera.position.set(x,y,z);
      camera.lookAt(cx,cy,cz);

      renderer.render(scene, camera);
      requestAnimationFrame(frame);
    }
    frame();
  </script>
</body>
</html>
