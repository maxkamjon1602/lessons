<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Lesson 09 · Step 7/7 — Presets & Performance (fixed)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0e0e12}
  #app{width:100%;height:100%}
  .overlay{position:fixed;top:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.55);border-radius:8px;color:#fff;font:14px monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.5);border-radius:8px;color:#fff;font:12px monospace}
  .hud{position:fixed;top:8px;right:8px;padding:6px 10px;background:rgba(0,0,0,.55);border-radius:8px;color:#bfe;font:12px monospace;line-height:1.25;white-space:pre}
  .error{position:fixed;left:8px;right:8px;bottom:8px;padding:10px;border-radius:10px;background:#2a0000;color:#ffd2d2;font:12px/1.4 monospace;white-space:pre-wrap;max-height:40%;overflow:auto;display:none}
</style>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="label" class="overlay">Preset: Filmic (2)</div>
<div class="help">
  Presets <b>1</b>=Clean(FXAA) · <b>2</b>=Filmic(FXAA+Grade) · <b>3</b>=Dreamy(Bloom+Grade) · <b>0</b>=Off (raw)<br/>
  Bloom <b>[</b>/<b>]</b> strength · <b>;</b>/<b>'</b> radius · <b>,</b>/<b>.</b> threshold · Reset <b>R</b><br/>
  Grade <b>U</b>=lift, <b>I</b>=gamma, <b>O</b>=gain (hold <b>Shift</b> = −) · DPR <b>P</b> · Neon <b>D</b><br/>
  Drag=orbit · Shift+Drag=pan · Wheel=dolly
</div>
<div id="hud" class="hud"></div>
<div id="err" class="error"></div>

<script type="module">
const showErr = (e)=>{const el=document.getElementById('err'); el.style.display='block'; el.textContent=(e&&(e.stack||e.message))||String(e);};

(async()=>{
try{
  const THREE = await import('three');
  const { EffectComposer }  = await import('https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js');
  const { RenderPass }      = await import('https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/RenderPass.js');
  const { ShaderPass }      = await import('https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/ShaderPass.js');
  const { FXAAShader }      = await import('https://unpkg.com/three@0.158.0/examples/jsm/shaders/FXAAShader.js');
  const { UnrealBloomPass } = await import('https://unpkg.com/three@0.158.0/examples/jsm/postprocessing/UnrealBloomPass.js');

  const app=document.getElementById('app');
  const label=document.getElementById('label');
  const hudEl=document.getElementById('hud');

  // Renderer (device DPR by default; toggle with P)
  const renderer=new THREE.WebGLRenderer({antialias:false});
  app.appendChild(renderer.domElement);
  let useDPR1=false;
  const applyDPR=()=>renderer.setPixelRatio(useDPR1?1:Math.min(window.devicePixelRatio||1,2));
  applyDPR();
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setClearColor(0x0e0e12);
  if('outputColorSpace'in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace=THREE.SRGBColorSpace;
  else if('outputEncoding'in renderer && THREE.sRGBEncoding) renderer.outputEncoding=THREE.sRGBEncoding;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;

  // Scene scaffold
  const scene=new THREE.Scene();
  const ground=new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({color:0x232736,roughness:0.95}));
  ground.rotation.x=-Math.PI/2; ground.position.y=-1; scene.add(ground);
  const grid=new THREE.GridHelper(20,20,0x3a456f,0x2b3350); grid.position.y=-0.999; scene.add(grid);
  const mat1=new THREE.MeshStandardMaterial({color:0x88ccff,roughness:0.35,emissive:0x223344,emissiveIntensity:0.25});
  const mat2=new THREE.MeshStandardMaterial({color:0xffc36e,roughness:0.55,emissive:0x442200,emissiveIntensity:0.18});
  const mat3=new THREE.MeshPhysicalMaterial({color:0xD4AF37,metalness:1,roughness:0.2,emissive:0x111111,emissiveIntensity:0.1});
  const sphere=new THREE.Mesh(new THREE.SphereGeometry(1.2,48,48),mat1);
  const cube=new THREE.Mesh(new THREE.BoxGeometry(2,2,2),mat2);
  const pyramid=new THREE.Mesh(new THREE.ConeGeometry(1.1,1.8,5),mat3);
  sphere.position.x=-3; pyramid.position.x=3; scene.add(sphere,cube,pyramid);

  // Neon helper (toggle D)
  const demoGroup=new THREE.Group();
  (()=>{
    const neonMat=new THREE.MeshStandardMaterial({color:0xffffff,emissive:0xffffff,emissiveIntensity:1.1,roughness:0.2,metalness:0.2});
    const ring=new THREE.Mesh(new THREE.TorusGeometry(2.2,0.035,24,256),neonMat);
    ring.position.set(0,0.6,-1.4); ring.rotation.x=Math.PI*0.5;
    const mkStrip=(len,thk)=>new THREE.Mesh(new THREE.BoxGeometry(len,thk,thk),neonMat);
    const s1=mkStrip(11,0.03); s1.position.set(0,1.1,0); s1.rotation.z=0.10*Math.PI;
    const s2=mkStrip(11,0.03); s2.position.set(0,0.2,0); s2.rotation.z=-0.12*Math.PI;
    demoGroup.add(ring,s1,s2); scene.add(demoGroup);
  })();
  let demoOn=true;

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff,0.35));
  const dir=new THREE.DirectionalLight(0xffffff,1); dir.position.set(6,10,6); scene.add(dir);

  // Camera + manual orbit/pan/dolly
  const camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,300);
  let theta=-0.4,phi=0.30,distance=9,panX=0,panY=0;
  function updateCamera(){
    const cx=panX,cy=panY,cz=0;
    const x=cx+distance*Math.cos(phi)*Math.cos(theta);
    const y=cy+distance*Math.sin(phi);
    const z=cz+distance*Math.cos(phi)*Math.sin(theta);
    camera.position.set(x,y,z); camera.lookAt(cx,cy,cz);
  }
  updateCamera();
  let isDown=false,lastX=0,lastY=0,shift=false;
  renderer.domElement.addEventListener('pointerdown',e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;shift=e.shiftKey;});
  addEventListener('pointerup',()=>isDown=false);
  addEventListener('pointermove',e=>{
    if(!isDown)return;
    const dx=(e.clientX-lastX)/window.innerWidth,dy=(e.clientY-lastY)/window.innerHeight;
    if(shift){panX-=dx*6;panY+=dy*6;} else {theta-=dx*3.2;phi=Math.max(-1.2,Math.min(1.2,phi-dy*2.4));}
    lastX=e.clientX;lastY=e.clientY;updateCamera();
  });
  addEventListener('wheel',e=>{distance=Math.max(3,Math.min(40,distance+Math.sign(e.deltaY)*0.8));updateCamera();},{passive:true});

  // Post-processing
  const composer=new EffectComposer(renderer);
  const renderPass=new RenderPass(scene,camera);
  composer.addPass(renderPass);

  const fxaa=new ShaderPass(FXAAShader);
  const setFXAARes=()=>fxaa.material.uniforms.resolution.value.set(1/window.innerWidth,1/window.innerHeight);
  setFXAARes();

  // Bloom with clamps
  const bloom=new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),0.9,0.7,0.84);
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
  function clampBloom(){
    bloom.strength = clamp(bloom.strength, 0, 5);
    bloom.radius   = clamp(bloom.radius,   0, 5);
    bloom.threshold= clamp(bloom.threshold,0, 1);
  }
  clampBloom();

  // Filmic (lift/gamma/gain) with clamps & defaults
  const FilmicShader={
    uniforms:{tDiffuse:{value:null}, lift:{value:new THREE.Vector3(.02,.02,.02)}, gamma:{value:new THREE.Vector3(1.05,1.05,1.05)}, gain:{value:new THREE.Vector3(1.06,1.06,1.06)}},
    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader:`uniform sampler2D tDiffuse; uniform vec3 lift,gamma,gain; varying vec2 vUv;
      void main(){
        vec2 uv=vUv-0.5; float v=1.0 - smoothstep(0.2,0.9,length(uv)*1.45);
        vec4 c=texture2D(tDiffuse, vUv);
        c.rgb=(c.rgb+lift); c.rgb=pow(max(c.rgb,0.0),gamma); c.rgb*=gain;
        c.rgb*=mix(1.0, v, 0.28);
        gl_FragColor=c;
      }`
  };
  const filmic=new ShaderPass(FilmicShader);
  const clampVec3=(vec,min,max)=>{
    vec.set(clamp(vec.x,min,max), clamp(vec.y,min,max), clamp(vec.z,min,max));
  };
  function clampGrade(){
    clampVec3(filmic.uniforms.lift.value,  -0.5, 0.5);
    clampVec3(filmic.uniforms.gamma.value,  0.5, 2.5);
    clampVec3(filmic.uniforms.gain.value,   0.5, 2.0);
  }
  function resetGrade(){
    filmic.uniforms.lift.value.set(0.02,0.02,0.02);
    filmic.uniforms.gamma.value.set(1.05,1.05,1.05);
    filmic.uniforms.gain.value.set(1.06,1.06,1.06);
  }

  // Presets
  let preset='filmic';
  let useComposer=true;
  function applyPreset(name){
    composer.passes.length=1; // keep renderPass
    if(name==='clean'){ composer.addPass(fxaa); }
    if(name==='filmic'){ composer.addPass(fxaa); composer.addPass(filmic); }
    if(name==='dreamy'){ composer.addPass(bloom); composer.addPass(filmic); }
    if(name==='off'){ /* only renderPass; handled in loop */ }
    preset=name; useComposer=(name!=='off');
    label.textContent=`Preset: ${name[0].toUpperCase()+name.slice(1)} (${name==='clean'?1:name==='filmic'?2:name==='dreamy'?3:0})`;
  }
  applyPreset('filmic');

  // Controls (with clamps + reset)
  addEventListener('keydown',e=>{
    const k=e.key;
    // Presets
    if(k==='1') applyPreset('clean');
    if(k==='2') applyPreset('filmic');
    if(k==='3') applyPreset('dreamy');
    if(k==='0') applyPreset('off');

    // Bloom
    if(k==='['){ bloom.strength-=0.05; clampBloom(); }
    if(k===']'){ bloom.strength+=0.05; clampBloom(); }
    if(k===';'){ bloom.radius  -=0.05; clampBloom(); }
    if(k==="'"){ bloom.radius  +=0.05; clampBloom(); }
    if(k===','){ bloom.threshold-=0.02; clampBloom(); }
    if(k==='.') { bloom.threshold+=0.02; clampBloom(); }
    if(k.toLowerCase()==='r'){ // reset bloom & grade
      bloom.strength=0.9; bloom.radius=0.7; bloom.threshold=0.84; clampBloom();
      resetGrade();
    }

    // Grade (U/I/O) — Shift = negative step
    const step = e.shiftKey ? -0.05 : 0.05;
    if(k.toLowerCase()==='u'){ filmic.uniforms.lift.value.addScalar(step);  clampGrade(); }
    if(k.toLowerCase()==='i'){ filmic.uniforms.gamma.value.addScalar(step); clampGrade(); }
    if(k.toLowerCase()==='o'){ filmic.uniforms.gain.value.addScalar(step);  clampGrade(); }

    // Misc
    if(k.toLowerCase()==='d'){ demoOn=!demoOn; demoGroup.visible=demoOn; }
    if(k.toLowerCase()==='p'){ useDPR1=!useDPR1; applyDPR(); onResize(); }
  });

  // Resize
  function onResize(){
    renderer.setSize(window.innerWidth,window.innerHeight);
    camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    composer.setSize(window.innerWidth,window.innerHeight);
    bloom.setSize(window.innerWidth,window.innerHeight);
    setFXAARes();
  }
  addEventListener('resize', onResize);

  // HUD
  let lastT=performance.now(), emaMs=16.7, emaFps=60;
  function updateHUD(now){
    const dt=now-lastT; lastT=now;
    const a=0.1; emaMs=emaMs+a*(dt-emaMs); emaFps=emaFps+a*((1000/dt)-emaFps);
    const L=filmic.uniforms.lift.value.x, Gm=filmic.uniforms.gamma.value.x, Gn=filmic.uniforms.gain.value.x;
    hudEl.textContent =
`fps ${emaFps.toFixed(0)}  ms ${emaMs.toFixed(1)}  DPR ${renderer.getPixelRatio().toFixed(2)}
passes ${useComposer ? (composer.passes.length-1) : 0}  preset ${preset}
bloom s:${bloom.strength.toFixed(2)} r:${bloom.radius.toFixed(2)} t:${bloom.threshold.toFixed(2)}
grade lift:${L.toFixed(2)} gamma:${Gm.toFixed(2)} gain:${Gn.toFixed(2)}`;
  }

  // RAF (single loop; no duplicates)
  function loop(now){
    updateCamera();
    if(useComposer) composer.render(); else renderer.render(scene,camera);
    updateHUD(now||performance.now());
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

}catch(e){ showErr(e); }
})();
</script>
</body>
</html>
