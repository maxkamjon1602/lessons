<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>L06 · Step 07 — Final scene polish (v2)</title>
  <style>
    html,body{margin:0;height:100%}
    #app{position:relative;width:100vw;height:100vh;background:#0e0e12;color:#fff;font:12px ui-monospace}
    .help{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,.5);padding:6px 8px;border-radius:6px}
  .overlay{position:fixed;top:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,0.55);border-radius:8px;color:#fff;font:14px monospace;}</style>
</head>
<body>
  <div id="app"></div>
<div class="overlay">Lesson 06 · Step 7/7 — Final scene polish (v2)</div>
  <div class="help">Drag/Wheel to orbit • 1=Perspective 2=Ortho</div>
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";
    const host = document.getElementById('app');

    function sizeCanvas(canvas, dprMax=2){
      const dpr = Math.min(window.devicePixelRatio||1, dprMax);
      const rect = host.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr);
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      return { w: canvas.width, h: canvas.height, dpr };
    }
    function updateCameraOnResize(cam,size){
      if (cam.isPerspectiveCamera){ cam.aspect=size.w/size.h; cam.updateProjectionMatrix(); }
      else {
        const a=size.w/size.h; const fh=size.h/100; const fw=fh*a;
        cam.left=-fw/2; cam.right=fw/2; cam.top=fh/2; cam.bottom=-fh/2;
        cam.updateProjectionMatrix();
      }
    }
    function makePerspective(size){
      const c=new THREE.PerspectiveCamera(50,size.w/size.h,0.1,100);
      c.position.set(4,2,7); c.lookAt(0,0,0); return c;
    }
    function makeOrtho(size){
      const a=size.w/size.h; const fh=size.h/100; const fw=fh*a;
      const c=new THREE.OrthographicCamera(-fw/2,fw/2,fh/2,-fh/2,-100,100);
      c.position.set(0,0,10); c.lookAt(0,0,0); return c;
    }

    // Wood, checker/bump, alpha, env
    
// Better wood: directional grain + ring turbulence
function makeWoodTexture(size=512){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const ctx=c.getContext('2d');
  function noise(x,y){
    const ix=Math.floor(x), iy=Math.floor(y);
    const fx=x-ix, fy=y-iy;
    function r(i,j){ const n=(i*73856093 ^ j*19349663)>>>0; return ((n%1000)/1000); }
    const a=r(ix,iy), b=r(ix+1,iy), d=r(ix,iy+1), e=r(ix+1,iy+1);
    const wx = fx*fx*(3-2*fx), wy = fy*fy*(3-2*fy);
    const ab = a*(1-wx)+b*wx, de = d*(1-wx)+e*wx;
    return ab*(1-wy)+de*wy;
  }
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const nx = x/size, ny = y/size;
      const warp = noise(nx*8, ny*8)*0.25;
      const gx = nx*16 + warp, gy = ny*2 + noise(nx*4,ny*4)*0.1;
      const rings = Math.sin((nx*2 + ny*0.2 + noise(nx*6,ny*6)*0.4) * Math.PI*6);
      const grain = Math.sin(gx*Math.PI*2)*0.5 + Math.sin(gy*Math.PI*8)*0.5;
      const t = (rings*0.35 + grain*0.15 + 0.5);
      const rC = Math.floor(110 + t*85);
      const gC = Math.floor(80  + t*65);
      const bC = Math.floor(50  + t*35);
      ctx.fillStyle=`rgb(${rC},${gC},${bC})`;
      ctx.fillRect(x,y,1,1);
    }
  }
  const tex=new THREE.CanvasTexture(c);
  tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
  tex.anisotropy=8;
  return tex;
}

    
function makeChecker(size=512, squares=12, c1='#e6e6e6', c2='#bfc3cd'){
  const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
  const step=size/squares;
  for(let y=0;y<squares;y++) for(let x=0;x<squares;x++){
    ctx.fillStyle=((x+y)%2===0)?c1:c2; ctx.fillRect(x*step,y*step,step,step);
  }
  const tex=new THREE.CanvasTexture(c);
  tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.anisotropy=4;
  return tex;
}
function makeBumpFromChecker(size=512, squares=12){
  const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
  const step=size/squares;
  for(let y=0;y<squares;y++) for(let x=0;x<squares;x++){
    const v=((x+y)%2===0)? 210 : 120;
    ctx.fillStyle=`rgb(${v},${v},${v})`;
    ctx.fillRect(x*step,y*step,step,step);
  }
  const tex=new THREE.CanvasTexture(c);
  tex.wrapS=tex.wrapT=THREE.RepeatWrapping; return tex;
}

    function makeAlpha(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
      g.addColorStop(0,'white'); g.addColorStop(1,'rgba(0,0,0,0.25)');
      ctx.fillStyle=g; ctx.fillRect(0,0,size, size);
      return new THREE.CanvasTexture(c);
    }
    
// Procedural environment cube (soft studio look)
function makeFace(colorTop, colorBottom){
  const s=512; const c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
  const g=ctx.createLinearGradient(0,0,0,s); g.addColorStop(0,colorTop); g.addColorStop(1,colorBottom);
  ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
  ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,s*0.45,s,s*0.1);
  return c;
}
function makeCubeTexture(){
  const px=makeFace('#a8c8ff','#2a2f47'); const nx=makeFace('#a8c8ff','#2a2f47');
  const py=makeFace('#ffffff','#a8c8ff'); const ny=makeFace('#3a3f59','#10121a');
  const pz=makeFace('#a8c8ff','#2a2f47'); const nz=makeFace('#a8c8ff','#2a2f47');
  const cube=new THREE.CubeTexture([px,nx,py,ny,pz,nz]); cube.needsUpdate=true; return cube;
}


    // Renderer
    const canvas = document.createElement('canvas'); host.appendChild(canvas);
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias:true });
    renderer.setClearColor(0x0e0e12, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    let size = sizeCanvas(canvas, 2);
    renderer.setPixelRatio(size.dpr);
    renderer.setSize(size.w/size.dpr, size.h/size.dpr, false);

    const scene = new THREE.Scene();
    let camera = makePerspective(size);

    const envCube = makeCubeTexture();
    scene.background = envCube;
    const pmrem = new THREE.PMREMGenerator(renderer);
    const envRT = pmrem.fromCubemap(envCube);
    scene.environment = envRT.texture;

    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,5); scene.add(dir);
    const point = new THREE.PointLight(0xffd2a1, 0.8, 30); point.position.set(-4,3,4); scene.add(point);

    const wood = new THREE.Mesh(new THREE.PlaneGeometry(1.6,1.6), new THREE.MeshStandardMaterial({ map: makeWoodTexture(), roughness: 0.7, metalness: 0.0 }));
    wood.material.envMapIntensity = 0.2; wood.position.set(-2.2, 0, 0);

    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.6,1.6), new THREE.MeshStandardMaterial({ map: makeChecker(), bumpMap: makeBumpFromChecker(), bumpScale: 0.08, roughness: 0.55, metalness: 0.0 }));
    cube.material.envMapIntensity = 0.3; cube.position.set(0, 0, 0);

    const triGeom = new THREE.BufferGeometry();
    triGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0.9,0, -0.8,-0.7,0, 0.8,-0.7,0]), 3));
    triGeom.computeVertexNormals();
    const glass = new THREE.Mesh(triGeom, new THREE.MeshPhysicalMaterial({ color: 0xffffff, transmission: 0.95, thickness: 0.15, ior: 1.5, roughness: 0.02, metalness: 0.0, attenuationColor: new THREE.Color(0x88ccff), attenuationDistance: 2.0, transparent: true, opacity: 1.0, side: THREE.DoubleSide, depthWrite: false }));
    glass.material.envMapIntensity = 1.0; glass.position.set(2.2, 0, 0);

    const pyramid = new THREE.Mesh(new THREE.ConeGeometry(0.9,1.3,4), new THREE.MeshPhysicalMaterial({ color: 0xD4AF37, metalness: 1.0, roughness: 0.18, clearcoat: 0.3, clearcoatRoughness: 0.15 }));
    pyramid.material.envMapIntensity = 1.6; pyramid.position.set(0, 0, -2.2); pyramid.rotation.y = Math.PI*0.25;

    scene.add(wood, cube, glass, pyramid);

    const target = new THREE.Vector3(0,0,0);
    let isDown=false,lastX=0,lastY=0,theta=0,phi=0,radius=7.5;
    canvas.addEventListener('pointerdown', e=>{isDown=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId);});
    canvas.addEventListener('pointerup', e=>{isDown=false; canvas.releasePointerCapture?.(e.pointerId);});
    canvas.addEventListener('pointermove', e=>{ if(!isDown)return; const dx=(e.clientX-lastX)*0.005, dy=(e.clientY-lastY)*0.005; lastX=e.clientX; lastY=e.clientY; theta-=dx; phi=Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, phi-dy)); });
    canvas.addEventListener('wheel', e=>{ radius=Math.max(2, Math.min(30, radius + e.deltaY*0.001*radius)); }, { passive:true });

    window.addEventListener('keydown', (e)=>{ if (e.code === 'Digit1') camera = makePerspective(size); if (e.code === 'Digit2') camera = makeOrtho(size); });

    const clock = new THREE.Clock();
    (function loop(){
      const dt = clock.getDelta();
      wood.rotation.y   += dt * 0.25;
      cube.rotation.x   += dt * 0.35; cube.rotation.y += dt * 0.55;
      glass.rotation.z  += dt * 0.25;
      pyramid.rotation.y+= dt * 0.35;

      const x = target.x + radius * Math.cos(phi) * Math.cos(theta);
      const y = target.y + radius * Math.sin(phi);
      const z = target.z + radius * Math.cos(phi) * Math.sin(theta);
      camera.position.set(x,y,z); camera.lookAt(target);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();

    const ro = new ResizeObserver(()=>{
      size = sizeCanvas(canvas, 2);
      renderer.setPixelRatio(size.dpr);
      renderer.setSize(size.w/size.dpr, size.h/size.dpr, false);
      updateCameraOnResize(camera, size);
    });
    ro.observe(host);
  </script>
</body>
</html>
