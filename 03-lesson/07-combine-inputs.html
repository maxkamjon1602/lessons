<!doctype html><html lang="en"><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lesson 3 — Step 07 (Combine Inputs)</title>
<style>
  html,body{margin:0;height:100%;background:#0f1117;color:#e6e6e6;font-family:system-ui,Segoe UI,Roboto,sans-serif}
  canvas{display:block;width:100%;height:100%}
  #controls{position:absolute;top:10px;left:10px;display:flex;gap:12px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:8px;font-size:14px}
  #controls button, #controls label, #controls input, #controls select{cursor:pointer}
  #controls button{background:#1a1d2b;color:#e6e6e6;border:1px solid #444;border-radius:6px;padding:4px 10px}
  #controls button:hover{background:#2d3144}
  #hint{position:absolute;bottom:10px;left:10px;font-size:12px;color:#9aa4b2;background:rgba(0,0,0,.35);padding:6px 8px;border-radius:6px}
.overlay{position:fixed;top:8px;right:8px;padding:6px 10px;background:rgba(0,0,0,0.55);border-radius:8px;color:#fff;font:14px monospace;}</style>
</head><body>
<div id="controls"><span>Arrows move square • Mouse moves triangle • Space resets square</span></div>
<canvas id="c"></canvas>
<div class="overlay">Lesson 03 · Step 7/7 — Combine Inputs</div>
<div id="hint">Step 07: Combine keyboard + mouse controls</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x0f1117, 1);

const scene = new THREE.Scene();
let cam = makeOrtho();
function makeOrtho() { 
  const w = renderer.domElement.clientWidth, h = renderer.domElement.clientHeight;
  const ocam = new THREE.OrthographicCamera(0, w, 0, h, -500, 500);
  ocam.position.z = 200; ocam.updateProjectionMatrix(); return ocam;
}
function resize() {
  const need = canvas.width!==Math.floor(canvas.clientWidth*devicePixelRatio) ||
               canvas.height!==Math.floor(canvas.clientHeight*devicePixelRatio);
  if (need) { renderer.setSize(canvas.clientWidth, canvas.clientHeight, false); cam = makeOrtho(); }
}

// Shapes (same APIs as L1/L2)
function addSquare(x,y,size,color){
  const g=new THREE.PlaneGeometry(size,size);
  const m=new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(g,m);
  // center offset so (x,y) acts like top-left at creation time
  mesh.position.set(x+size/2, y+size/2, 0);
  mesh.userData={type:'square',size};
  return mesh;
}
function addTriangle(x,y,w,h,color){
  const s=new THREE.Shape(); s.moveTo(w/2,0); s.lineTo(0,h); s.lineTo(w,h); s.closePath();
  const g=new THREE.ShapeGeometry(s);
  const m=new THREE.MeshBasicMaterial({color, side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(g,m);
  // triangle is authored in local 0..w,0..h so (x,y) is top-left
  mesh.position.set(x, y, 0);
  mesh.userData={type:'triangle',w,h};
  return mesh;
}

// coordinate helpers
function getMouseScenePos(e){
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left);
  const y = (e.clientY - r.top);
  return {x,y};
}

const sqSize=120, triW=140, triH=120;
const start = {x:80,y:100};
const triStart = {x:240,y:100};
const square = addSquare(start.x,start.y,sqSize,0xffffff);
const triangle = addTriangle(triStart.x,triStart.y,triW,triH,0x00ccff);
scene.add(square); scene.add(triangle);

// keyboard (square)
const keys = {ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false};
addEventListener('keydown', e=>{
  if(e.key in keys){ keys[e.key]=true; e.preventDefault(); }
  if(e.code==='Space'){ square.position.set(start.x+sqSize/2, start.y+sqSize/2, 0); triangle.position.set(triStart.x, triStart.y, 0); e.preventDefault(); }
});
addEventListener('keyup',   e=>{ if(e.key in keys){ keys[e.key]=false; e.preventDefault(); } });

// mouse (triangle follows)
addEventListener('mousemove', e=>{
  const {x,y} = getMouseScenePos(e);
  triangle.position.set(x - triW/2, y - triH/2, 0);
  const minX = cam.left,  maxX = cam.right - triW;
  const minY = cam.top,   maxY = cam.bottom - triH;
  triangle.position.x = Math.max(minX, Math.min(maxX, triangle.position.x));
  triangle.position.y = Math.max(minY, Math.min(maxY, triangle.position.y));
});

// loop
const SPEED = 260; let last=performance.now();
function tick(now){
  resize();
  const dt = Math.min(0.05, (now-last)/1000); last=now;
  let dx=0, dy=0;
  if(keys.ArrowLeft)  dx-=SPEED*dt;
  if(keys.ArrowRight) dx+=SPEED*dt;
  if(keys.ArrowUp)    dy-=SPEED*dt;
  if(keys.ArrowDown)  dy+=SPEED*dt;
  square.position.x += dx; square.position.y += dy;
  // clamp for square (center-based)
  const maxX = cam.right - sqSize/2, minX = cam.left + sqSize/2;
  const maxY = cam.bottom - sqSize/2, minY = cam.top + sqSize/2;
  square.position.x = Math.max(minX, Math.min(maxX, square.position.x));
  square.position.y = Math.max(minY, Math.min(maxY, square.position.y));

  renderer.render(scene, cam);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

addEventListener('resize', resize);
</script>
</body></html>
