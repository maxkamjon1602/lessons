<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 10 · Step 3/7 — Parallax Layers (Clarity Patch)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0e0e12}
  #app{width:100%;height:100%}
  .overlay{position:fixed;top:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.55);border-radius:8px;color:#fff;font:14px/1.3 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.5);border-radius:8px;color:#fff;font:12px/1.35 monospace}
  .error{position:fixed;left:8px;right:8px;bottom:8px;padding:10px;border-radius:10px;background:#2a0000;color:#ffd2d2;font:12px/1.4 monospace;white-space:pre-wrap;max-height:40%;overflow:auto;display:none}
  #safe{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;border:1px dashed rgba(255,255,255,.45)}
</style>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
</script>
</head>
<body>
<div id="app"></div>
<div id="mode" class="overlay">L10 · Step 3 — Ortho · 64 px/unit · bg 0.25 · mid 1.00 · fg 1.50</div>
<div class="help">
  Pan: drag · Density: <b>K</b>/<b>L</b> (or wheel) · Toggle Ortho/Persp: <b>P</b> ·
  Presets: <b>1</b>=Subtle · <b>2</b>=Filmic · <b>3</b>=Arcade · <b>4</b>=Extreme ·
  <b>Space</b>=Auto-pan · <b>H</b>=Debug bars
</div>
<div id="safe"></div>
<div id="err" class="error"></div>

<script type="module">
const showErr = (e) => { const el=document.getElementById('err'); el.style.display='block'; el.textContent=(e&&(e.stack||e.message))||String(e); };

(async()=>{
try{
  const THREE = await import('three');

  const app    = document.getElementById('app');
  const modeEl = document.getElementById('mode');
  const safeEl = document.getElementById('safe');

  // ----- Renderer -----
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  app.appendChild(renderer.domElement);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x0e0e12);
  if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;

  // ----- Scene root -----
  const scene = new THREE.Scene();

  // Layer groups (bg < 1 < fg)
  const bg  = new THREE.Group();  bg.userData.parallax  = 0.25;
  const mid = new THREE.Group();  mid.userData.parallax = 1.00;
  const fg  = new THREE.Group();  fg.userData.parallax  = 1.50;
  bg.position.z  = -10; mid.position.z = 0; fg.position.z  = 10;
  scene.add(bg, mid, fg);

  // ----- Background sky gradient -----
  const sky = new THREE.Mesh(
    new THREE.PlaneGeometry(1,1),
    new THREE.ShaderMaterial({
      uniforms:{ top:{value:new THREE.Color(0x1a2030)}, bottom:{value:new THREE.Color(0x0c0f18)} },
      vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader:`uniform vec3 top; uniform vec3 bottom; varying vec2 vUv;
        void main(){ vec3 c = mix(bottom, top, clamp(vUv.y,0.0,1.0)); gl_FragColor=vec4(c,1.0); }`
    })
  );
  sky.renderOrder = -100; bg.add(sky);

  // BG silhouettes
  const bgMat = new THREE.MeshStandardMaterial({ color:0x161b28, roughness:1 });
  const mkBlock = (w,h,x,y)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,0.2), bgMat); m.position.set(x,y,0); return m; };
  bg.add(mkBlock(8,1.0,-7,-0.2), mkBlock(6,1.3,-1.5,-0.2), mkBlock(9,1.1,5.5,-0.3));

  // ----- Mid layer: original scaffold -----
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({ color:0x232736, roughness:0.95 }));
  ground.rotation.x = -Math.PI/2; ground.position.y = -1; mid.add(ground);
  const grid = new THREE.GridHelper(20,20,0x3a456f,0x2b3350); grid.position.y = -0.999; mid.add(grid);
  const mat1 = new THREE.MeshStandardMaterial({ color:0x88ccff, roughness:0.35 });
  const mat2 = new THREE.MeshStandardMaterial({ color:0xffc36e, roughness:0.55 });
  const mat3 = new THREE.MeshPhysicalMaterial({ color:0xD4AF37, metalness:1, roughness:0.2 });
  const sphere  = new THREE.Mesh(new THREE.SphereGeometry(1.2,48,48), mat1);
  const cube    = new THREE.Mesh(new THREE.BoxGeometry(2,2,2),       mat2);
  const pyramid = new THREE.Mesh(new THREE.ConeGeometry(1.1,1.8,5),  mat3);
  sphere.position.x = -3; pyramid.position.x = 3; mid.add(sphere, cube, pyramid);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff,0.35));
  const dir = new THREE.DirectionalLight(0xffffff,1); dir.position.set(6,10,6); scene.add(dir);

  // FG accents (fast near layer)
  const fgMat = new THREE.MeshStandardMaterial({ color:0x2e3550, roughness:0.8 });
  const mkStrip = (w,h,x,y)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,0.1), fgMat); m.position.set(x,y,0); return m; };
  fg.add(mkStrip(5.5,0.14,-5.0,-0.5), mkStrip(4.0,0.12,0.0,-0.7), mkStrip(6.0,0.16,5.0,-0.6));

  // ----- Debug bars (toggle with H) -----
  const debug = new THREE.Group(); scene.add(debug);
  function addBars(group, color, z){
    const bars = new THREE.Group(); bars.position.z = z;
    const mat = new THREE.MeshBasicMaterial({ color });
    for(let i=-20;i<=20;i+=2){
      const bar = new THREE.Mesh(new THREE.BoxGeometry(0.05, 6, 0.01), mat);
      bar.position.set(i, 1.5, 0);
      bars.add(bar);
    }
    group.add(bars);
    return bars;
  }
  const barsBG  = addBars(debug, 0x4a78ff, -9);   // blue-ish
  const barsMID = addBars(debug, 0xffffff,  0);   // white
  const barsFG  = addBars(debug, 0xff7a4a,  9);   // orange-ish
  debug.visible = false;

  // ----- Cameras (pixel-consistent Ortho + Persp) -----
  let PIXELS_PER_UNIT = 64;  const MIN_PPU=16, MAX_PPU=256;
  const aspect = ()=> window.innerWidth / window.innerHeight;

  const ortho = new THREE.OrthographicCamera(-1,1,1,-1, 0.1, 1000);
  ortho.position.set(0,0,10); ortho.lookAt(0,0,0);

  const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
  let perspDist = 10; persp.position.set(0,0,perspDist); persp.lookAt(0,0,0);

  let usingOrtho = true; let camera = ortho;

  // Camera pan state
  let camX=0, camY=0;

  function visibleUnits(){ const halfH = (window.innerHeight / PIXELS_PER_UNIT) * 0.5; return [halfH * aspect(), halfH]; }
  function sizeSky(){ const [halfW, halfH] = visibleUnits(); sky.scale.set(halfW*4, halfH*2, 1); }

  function updateOrtho(){
    const [halfW, halfH] = visibleUnits();
    ortho.left=-halfW+camX; ortho.right=halfW+camX; ortho.top=halfH+camY; ortho.bottom=-halfH+camY;
    ortho.updateProjectionMatrix();
    ortho.position.set(camX, camY, 10); ortho.lookAt(camX, camY, 0);
    sizeSky();
  }
  function updatePersp(){
    persp.aspect = aspect(); persp.updateProjectionMatrix();
    persp.position.set(camX, camY, perspDist); persp.lookAt(camX, camY, 0);
  }

  function applyParallax(){
    [bg, mid, fg, barsBG, barsMID, barsFG].forEach(g=>{
      const f = (g===barsBG)?bg.userData.parallax :
                (g===barsMID)?mid.userData.parallax :
                (g===barsFG)?fg.userData.parallax :
                g.userData.parallax;
      g.position.x = camX * (1 - f);
      g.position.y = camY * (1 - f);
    });
  }

  function updateRig(){
    if(usingOrtho){ camera=ortho; updateOrtho(); } else { camera=persp; updatePersp(); }
    applyParallax();
    const [halfW, halfH] = visibleUnits();
    modeEl.textContent = `L10 · Step 3 — ${usingOrtho?'Ortho':'Perspective'} · ${PIXELS_PER_UNIT} px/unit · bg ${bg.userData.parallax.toFixed(2)} mid ${mid.userData.parallax.toFixed(2)} fg ${fg.userData.parallax.toFixed(2)} · view ${(halfW*2).toFixed(2)}×${(halfH*2).toFixed(2)}u`;
    safeEl.style.width  = Math.round(window.innerWidth*0.90)+'px';
    safeEl.style.height = Math.round(window.innerHeight*0.85)+'px';
  }
  updateRig();

  // ----- Input & controls -----
  let isDown=false,lastX=0,lastY=0;
  renderer.domElement.addEventListener('pointerdown',e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;});
  addEventListener('pointerup',()=>{isDown=false;});
  addEventListener('pointermove',e=>{
    if(!isDown) return;
    const dx=(e.clientX-lastX)/window.innerWidth, dy=(e.clientY-lastY)/window.innerHeight;
    if(usingOrtho){ const [halfW,halfH]=visibleUnits(); camX -= dx*(halfW*2); camY += dy*(halfH*2); }
    else { const worldH=2*Math.tan((Math.PI/180)*(camera.fov/2))*perspDist, worldW=worldH*aspect(); camX -= dx*worldW; camY += dy*worldH; }
    lastX=e.clientX; lastY=e.clientY; updateRig();
  });

  function setPPU(ppu){ PIXELS_PER_UNIT = THREE.MathUtils.clamp(ppu, MIN_PPU, MAX_PPU); updateRig(); }
  addEventListener('wheel', e=>{ const step=(PIXELS_PER_UNIT>=64)?4:2; setPPU(PIXELS_PER_UNIT - Math.sign(e.deltaY)*step); }, {passive:true});

  addEventListener('keydown', e=>{
    const k=e.key;
    if(k.toLowerCase()==='k') setPPU(PIXELS_PER_UNIT-4);
    if(k.toLowerCase()==='l') setPPU(PIXELS_PER_UNIT+4);
    if(k.toLowerCase()==='p'){ usingOrtho=!usingOrtho; updateRig(); }
    if(k==='1'){ bg.userData.parallax=0.40; mid.userData.parallax=1.00; fg.userData.parallax=1.20; updateRig(); }
    if(k==='2'){ bg.userData.parallax=0.25; mid.userData.parallax=1.00; fg.userData.parallax=1.50; updateRig(); }
    if(k==='3'){ bg.userData.parallax=0.10; mid.userData.parallax=1.00; fg.userData.parallax=1.60; updateRig(); }
    if(k==='4'){ bg.userData.parallax=0.05; mid.userData.parallax=1.00; fg.userData.parallax=1.80; updateRig(); } // EXTREME
    if(k.toLowerCase()==='h'){ debug.visible = !debug.visible; }
    if(k===' '){ autoPan = !autoPan; lastTime = performance.now(); }
  });

  // Resize
  addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); updateRig(); });

  // ----- Auto-pan demo -----
  let autoPan = false, lastTime = performance.now(), phase = 0;
  const AMP = 6;   // amplitude in world units
  const SPD = 0.6; // cycles per second
  function animateAutoPan(now){
    const dt = (now - lastTime) / 1000; lastTime = now;
    phase += dt * SPD * Math.PI*2;
    camX = Math.sin(phase) * AMP;
  }

  // ----- Loop -----
  function loop(now){
    if(autoPan) animateAutoPan(now||performance.now());
    updateRig();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

}catch(e){ showErr(e); }
})();
</script>
</body>
</html>
