<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 10 · Step 2/7 — Pixel Scale & Safe-Area</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0e0e12}
  #app{width:100%;height:100%}
  .overlay{position:fixed;top:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.55);border-radius:8px;color:#fff;font:14px/1.3 monospace}
  .help{position:fixed;bottom:8px;left:8px;padding:6px 10px;background:rgba(0,0,0,.5);border-radius:8px;color:#fff;font:12px/1.35 monospace}
  .error{position:fixed;left:8px;right:8px;bottom:8px;padding:10px;border-radius:10px;background:#2a0000;color:#ffd2d2;font:12px/1.4 monospace;white-space:pre-wrap;max-height:40%;overflow:auto;display:none}
  /* Safe-area frame (purely visual guide, adjustable later for letterboxing) */
  #safe{
    position:fixed;top:50%;left:50%;
    transform:translate(-50%,-50%);
    pointer-events:none;border:1px dashed rgba(255,255,255,.5);
    box-shadow: 0 0 0 9999px rgba(0,0,0,0); /* keep transparent surroundings */
  }
</style>

<!-- Import map so examples/jsm can resolve "three" if you add any later -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
  }
}
</script>
</head>
<body>
<div id="app"></div>
<div id="mode" class="overlay">L10 · Step 2 — Ortho · 64 px/unit</div>
<div class="help">
  Pan: drag · Adjust density: <b>K</b>/<b>L</b> · Wheel=±PPU · Toggle Ortho/Persp: <b>P</b><br/>
  This step locks a <i>pixel-consistent</i> scale: 1 world unit = fixed on-screen pixels.
</div>
<div id="safe"></div>
<div id="err" class="error"></div>

<script type="module">
const showErr = (e) => {
  const el = document.getElementById('err');
  el.style.display = 'block';
  el.textContent = (e && (e.stack || e.message)) || String(e);
};

(async () => {
  try {
    const THREE = await import('three');

    const app   = document.getElementById('app');
    const modeEl= document.getElementById('mode');
    const safeEl= document.getElementById('safe');

    // ----- Renderer -----
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    app.appendChild(renderer.domElement);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0e0e12);
    if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else if ('outputEncoding' in renderer && THREE.sRGBEncoding) {
      renderer.outputEncoding = THREE.sRGBEncoding;
    }
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    // ----- Scene (unchanged scaffold from L08) -----
    const scene = new THREE.Scene();

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(20,20),
      new THREE.MeshStandardMaterial({ color:0x232736, roughness:0.95 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -1;
    scene.add(ground);

    const grid = new THREE.GridHelper(20,20,0x3a456f,0x2b3350);
    grid.position.y = -0.999;
    scene.add(grid);

    const mat1 = new THREE.MeshStandardMaterial({ color:0x88ccff, roughness:0.35 });
    const mat2 = new THREE.MeshStandardMaterial({ color:0xffc36e, roughness:0.55 });
    const mat3 = new THREE.MeshPhysicalMaterial({ color:0xD4AF37, metalness:1, roughness:0.2 });
    const sphere  = new THREE.Mesh(new THREE.SphereGeometry(1.2,48,48), mat1);
    const cube    = new THREE.Mesh(new THREE.BoxGeometry(2,2,2),       mat2);
    const pyramid = new THREE.Mesh(new THREE.ConeGeometry(1.1,1.8,5),  mat3);
    sphere.position.x = -3; pyramid.position.x = 3;
    scene.add(sphere, cube, pyramid);

    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(6,10,6);
    scene.add(dir);

    // ----- Pixel-consistent Ortho rig -----
    // 1 world unit should occupy this many CSS pixels on screen
    let PIXELS_PER_UNIT = 64;               // tweak with K/L or wheel
    const MIN_PPU = 16, MAX_PPU = 256;      // sane bounds

    const aspect = () => window.innerWidth / window.innerHeight;

    // Ortho camera (we rebuild or update its frustum whenever size/PPU changes)
    const ortho = new THREE.OrthographicCamera(-1,1,1,-1, 0.1, 1000);
    ortho.position.set(0,0,10);
    ortho.lookAt(0,0,0);

    // Perspective (comparison only)
    const persp = new THREE.PerspectiveCamera(50, aspect(), 0.1, 1000);
    let perspDist = 10;
    persp.position.set(0,0,perspDist);
    persp.lookAt(0,0,0);

    let usingOrtho = true;
    let camera = ortho;

    // Pan state
    let camX = 0, camY = 0;

    function updateOrthoFrustum(){
      // Use CSS pixels so the mapping is consistent regardless of device DPR
      const viewWpx = window.innerWidth;
      const viewHpx = window.innerHeight;

      const halfH_units = (viewHpx / PIXELS_PER_UNIT) * 0.5;
      const halfW_units = halfH_units * aspect();

      ortho.left   = -halfW_units + camX;
      ortho.right  =  halfW_units + camX;
      ortho.top    =  halfH_units + camY;
      ortho.bottom = -halfH_units + camY;
      ortho.updateProjectionMatrix();

      ortho.position.set(camX, camY, 10);
      ortho.lookAt(camX, camY, 0);

      // Update HUD label
      const visW = (halfW_units*2).toFixed(2);
      const visH = (halfH_units*2).toFixed(2);
      modeEl.textContent = `L10 · Step 2 — ${usingOrtho?'Ortho':'Perspective'} · ${PIXELS_PER_UNIT} px/unit · ${visW}×${visH} units`;

      // Safe-area guide (here: 90% width × 85% height of the viewport for now)
      const safeW = Math.round(viewWpx * 0.90);
      const safeH = Math.round(viewHpx * 0.85);
      safeEl.style.width  = safeW + 'px';
      safeEl.style.height = safeH + 'px';
    }

    function updatePersp(){
      persp.aspect = aspect();
      persp.updateProjectionMatrix();
      persp.position.set(camX, camY, perspDist);
      persp.lookAt(camX, camY, 0);
      modeEl.textContent = `L10 · Step 2 — Perspective · compare only`;
    }

    function updateCameraRig(){
      if(usingOrtho){
        camera = ortho;
        updateOrthoFrustum();
      }else{
        camera = persp;
        updatePersp();
      }
    }
    updateCameraRig();

    // ----- Input: pan (drag), adjust density (K/L or wheel) -----
    let isDown=false, lastX=0, lastY=0;
    renderer.domElement.addEventListener('pointerdown', (e)=>{ isDown=true; lastX=e.clientX; lastY=e.clientY; });
    addEventListener('pointerup', ()=>{ isDown=false; });
    addEventListener('pointermove', (e)=>{
      if(!isDown) return;
      const dx = (e.clientX - lastX) / window.innerWidth;
      const dy = (e.clientY - lastY) / window.innerHeight;

      if (usingOrtho) {
        const halfH_units = (window.innerHeight / PIXELS_PER_UNIT) * 0.5;
        const halfW_units = halfH_units * aspect();
        camX -= dx * (halfW_units * 2);
        camY += dy * (halfH_units * 2);
      } else {
        const worldH = 2 * Math.tan((Math.PI/180)*(camera.fov/2)) * perspDist;
        const worldW = worldH * aspect();
        camX -= dx * worldW;
        camY += dy * worldH;
      }
      lastX = e.clientX; lastY = e.clientY;
      updateCameraRig();
    });

    function setPPU(ppu){
      PIXELS_PER_UNIT = THREE.MathUtils.clamp(ppu, MIN_PPU, MAX_PPU);
      updateCameraRig();
    }

    addEventListener('wheel', (e)=>{
      const delta = Math.sign(e.deltaY);
      const step = (PIXELS_PER_UNIT >= 64) ? 4 : 2; // smaller steps at low PPU
      setPPU(PIXELS_PER_UNIT - delta * step);       // wheel up = increase PPU
    }, { passive:true });

    addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if(k==='k') setPPU(PIXELS_PER_UNIT - 4);
      if(k==='l') setPPU(PIXELS_PER_UNIT + 4);
      if(k==='p'){ usingOrtho = !usingOrtho; updateCameraRig(); }
    });

    // Resize
    addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateCameraRig();
    });

    // ----- Loop -----
    function loop(){
      updateCameraRig();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    loop();

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
